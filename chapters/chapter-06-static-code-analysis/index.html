<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 6: Static Code Analysis | Inside the Machine</title>
  <link rel="stylesheet" href="/inside-the-machine/assets/css/main.css">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Chapter 6: Static Code Analysis" />
<meta name="author" content="Mohit Mishra" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Part 2: Disassembly and Analysis" />
<meta property="og:description" content="Part 2: Disassembly and Analysis" />
<link rel="canonical" href="https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-06-static-code-analysis/" />
<meta property="og:url" content="https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-06-static-code-analysis/" />
<meta property="og:site_name" content="Inside the Machine" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-27T18:30:02+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Chapter 6: Static Code Analysis" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mohit Mishra"},"dateModified":"2025-04-27T18:30:02+00:00","datePublished":"2025-04-27T18:30:02+00:00","description":"Part 2: Disassembly and Analysis","headline":"Chapter 6: Static Code Analysis","mainEntityOfPage":{"@type":"WebPage","@id":"https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-06-static-code-analysis/"},"url":"https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-06-static-code-analysis/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <div class="container">
    <a href="/inside-the-machine/" class="site-title">Inside the Machine</a>
    
    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
          </svg>
        </span>
      </label>

      <div class="trigger">
        <a class="page-link" href="/inside-the-machine/chapters">Chapters</a>
        <a class="page-link" href="/inside-the-machine/about">About</a>
        <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
          <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
          </svg>
          <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
        </button>
      </div>
    </nav>
  </div>
</header>
  
  <main class="container">
    <article class="chapter">
  <header class="chapter-header">
    <h1>Chapter 6: Static Code Analysis</h1>
    
    <div class="chapter-part">Part 2: Disassembly and Analysis</div>
    
  </header>

  <div class="chapter-content">
    <p><em>Part 2: Disassembly and Analysis</em></p>

<p>In this chapter, we’ll explore advanced static analysis techniques that help you move beyond basic disassembly to deeper program understanding. We’ll examine how to identify functions, analyze control flow, recognize data structures, and detect common algorithms and library code. These techniques will help you work more efficiently and effectively as a reverse engineer.</p>

<h2 id="beyond-basic-disassembly">Beyond Basic Disassembly</h2>

<p>Basic disassembly, as we explored in the previous chapter, converts machine code to assembly language. While essential, this is just the first step in static analysis. To truly understand a program, we need to:</p>

<ol>
  <li><strong>Reconstruct program structure</strong>: Identify functions, basic blocks, and their relationships</li>
  <li><strong>Analyze control flow</strong>: Understand how execution moves through the program</li>
  <li><strong>Track data flow</strong>: Follow how data is transformed and propagated</li>
  <li><strong>Recognize patterns</strong>: Identify common algorithms, library functions, and programming idioms</li>
  <li><strong>Infer high-level constructs</strong>: Map assembly patterns back to source-level concepts</li>
</ol>

<p>Modern disassemblers and static analysis tools automate many of these tasks, but understanding the underlying techniques is crucial for effective reverse engineering, especially when automated analysis falls short.</p>

<h2 id="function-identification-and-analysis">Function Identification and Analysis</h2>

<p>Functions are the fundamental organizational units in most programs. Identifying function boundaries, parameters, local variables, and return values is a critical first step in static analysis.</p>

<h3 id="identifying-function-boundaries">Identifying Function Boundaries</h3>

<p>Several techniques help identify where functions begin and end:</p>

<h4 id="prologue-and-epilogue-patterns">Prologue and Epilogue Patterns</h4>

<p>As we saw in the previous chapter, functions typically begin with a prologue that sets up the stack frame and end with an epilogue that restores the previous state:</p>

<p><strong>x86-64 Prologue Pattern:</strong></p>
<pre><code class="language-assembly">push rbp
mov rbp, rsp
sub rsp, X  ; X is the size of the stack frame
</code></pre>

<p><strong>x86-64 Epilogue Pattern:</strong></p>
<pre><code class="language-assembly">leave       ; equivalent to: mov rsp, rbp; pop rbp
ret
</code></pre>

<p><strong>ARM64 Prologue Pattern:</strong></p>
<pre><code class="language-assembly">stp x29, x30, [sp, #-16]!  ; Save frame pointer and link register
mov x29, sp                ; Set frame pointer
</code></pre>

<p><strong>ARM64 Epilogue Pattern:</strong></p>
<pre><code class="language-assembly">ldp x29, x30, [sp], #16    ; Restore frame pointer and link register
ret
</code></pre>

<p>Scanning for these patterns helps identify function entry and exit points, though optimized code may use variations or omit frame setup entirely for leaf functions (those that don’t call other functions).</p>

<h4 id="call-references">Call References</h4>

<p>Functions are typically targets of call instructions. By identifying all call targets in a binary, you can discover function entry points:</p>

<pre><code class="language-assembly">call 0x401500  ; 0x401500 is likely a function entry point
</code></pre>

<p>This approach works well for directly called functions but may miss functions called through pointers or virtual methods.</p>

<h4 id="symbol-information">Symbol Information</h4>

<p>When available, symbol tables provide direct information about function locations. Even stripped binaries often retain some symbolic information for external functions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x401500 &lt;_malloc&gt;:       push rbp
0x401501 &lt;_malloc+1&gt;:     mov rbp, rsp
</code></pre></div></div>

<h4 id="heuristic-analysis">Heuristic Analysis</h4>

<p>Modern disassemblers use sophisticated heuristics to identify functions, including:</p>
<ul>
  <li>Code reachability analysis</li>
  <li>Return instruction identification</li>
  <li>Stack pointer tracking</li>
  <li>Register usage patterns</li>
</ul>

<p>These heuristics work together to provide comprehensive function identification, even in complex or obfuscated code.</p>

<h3 id="function-signature-recovery">Function Signature Recovery</h3>

<p>Once you’ve identified a function, determining its signature (parameters and return value) is the next step.</p>

<h4 id="parameter-identification">Parameter Identification</h4>

<p>Parameters can be identified by analyzing how the function accesses data based on the calling convention:</p>

<p><strong>x86-64 System V (Linux/macOS):</strong>
Parameters appear in registers RDI, RSI, RDX, RCX, R8, R9, with additional parameters on the stack.</p>

<pre><code class="language-assembly">mov rax, [rdi]      ; Accessing first parameter
add rsi, 8          ; Modifying second parameter
</code></pre>

<p><strong>x86-64 Microsoft (Windows):</strong>
Parameters appear in registers RCX, RDX, R8, R9, with additional parameters on the stack.</p>

<pre><code class="language-assembly">test rcx, rcx       ; Testing first parameter
mov rax, [rdx+8]    ; Accessing field in second parameter
</code></pre>

<p><strong>ARM64:</strong>
Parameters appear in registers X0-X7.</p>

<pre><code class="language-assembly">cbz x0, .label      ; Checking if first parameter is zero
ldr x1, [x1, #16]   ; Loading from address in second parameter
</code></pre>

<h4 id="return-value-analysis">Return Value Analysis</h4>

<p>Return values are typically placed in specific registers before returning:</p>

<ul>
  <li>x86-64: RAX (with RDX for larger values)</li>
  <li>ARM64: X0 (with X1 for larger values)</li>
  <li>MIPS: $v0 (with $v1 for larger values)</li>
</ul>

<p>Tracking what values are placed in these registers before return instructions helps identify the function’s return value.</p>

<pre><code class="language-assembly">; x86-64 function returning a 32-bit integer
mov eax, 42
ret

; ARM64 function returning a pointer
mov x0, x19
ret
</code></pre>

<h4 id="stack-frame-analysis">Stack Frame Analysis</h4>

<p>Analyzing stack frame setup and access patterns reveals information about local variables and parameters:</p>

<pre><code class="language-assembly">; x86-64 with frame pointer
push rbp
mov rbp, rsp
sub rsp, 32         ; Allocate 32 bytes for local variables
mov [rbp-8], rdi    ; Store first parameter in local variable
mov rax, [rbp+16]   ; Access parameter passed on stack
</code></pre>

<p>By tracking these memory accesses, you can reconstruct the function’s local variable layout and parameter passing mechanism.</p>

<h3 id="function-type-inference">Function Type Inference</h3>

<p>Beyond basic signature recovery, inferring the types of parameters and return values provides deeper insight into a function’s purpose.</p>

<h4 id="pointer-vs-value-analysis">Pointer vs. Value Analysis</h4>

<p>How a value is used often reveals whether it’s a pointer or a direct value:</p>

<pre><code class="language-assembly">; Likely a pointer parameter
mov rax, [rdi]      ; Dereferencing rdi suggests it's a pointer

; Likely a numeric parameter
add eax, esi        ; Direct arithmetic on esi suggests it's a value
</code></pre>

<h4 id="size-inference">Size Inference</h4>

<p>The size of registers used in operations can indicate the size of the data type:</p>

<pre><code class="language-assembly">movzx eax, byte ptr [rdi]  ; Suggests rdi points to a byte (char)
mov eax, dword ptr [rsi]   ; Suggests rsi points to a 32-bit value (int)
</code></pre>

<h4 id="array-and-structure-detection">Array and Structure Detection</h4>

<p>Access patterns can reveal array or structure usage:</p>

<pre><code class="language-assembly">; Likely array access with index in rcx
mov rax, [rdi + rcx*8]     ; Accessing 8-byte elements (e.g., pointers)

; Likely structure field access
mov rax, [rdi + 16]        ; Accessing field at offset 16
</code></pre>

<h4 id="string-operation-detection">String Operation Detection</h4>

<p>Certain instruction sequences suggest string operations:</p>

<pre><code class="language-assembly">; Likely string comparison loop
.loop:
mov al, [rdi]
mov bl, [rsi]
cmp al, bl
jne .different
test al, al
jz .equal
inc rdi
inc rsi
jmp .loop
</code></pre>

<h3 id="function-classification">Function Classification</h3>

<p>Classifying functions by their behavior helps prioritize analysis efforts and understand program structure.</p>

<h4 id="utility-functions">Utility Functions</h4>

<p>Small, frequently called functions often perform utility operations like string manipulation, memory management, or data conversion.</p>

<pre><code class="language-assembly">; Likely a string length function
xor eax, eax        ; Initialize counter to 0
.loop:
cmp byte ptr [rdi], 0
je .done
inc rdi
inc eax
jmp .loop
.done:
ret
</code></pre>

<h4 id="wrapper-functions">Wrapper Functions</h4>

<p>Functions that perform minimal processing before calling another function are often wrappers that provide a simplified interface or additional checks.</p>

<pre><code class="language-assembly">; Likely a wrapper function
test rdi, rdi
jz .error
call _internal_function
ret
.error:
xor eax, eax
ret
</code></pre>

<h4 id="constructordestructor-functions">Constructor/Destructor Functions</h4>

<p>Functions that initialize or clean up data structures often have distinctive patterns:</p>

<pre><code class="language-assembly">; Likely a constructor
mov rdi, 24         ; Size to allocate
call _malloc
test rax, rax
jz .error
mov qword ptr [rax], 0     ; Initialize fields
mov qword ptr [rax+8], 0
mov dword ptr [rax+16], 1
ret
</code></pre>

<h4 id="algorithm-implementation-functions">Algorithm Implementation Functions</h4>

<p>Functions implementing specific algorithms often have recognizable structures like nested loops, table lookups, or mathematical operations.</p>

<pre><code class="language-assembly">; Likely a hash function (simplified example)
mov eax, 5381       ; Initial hash value
.loop:
movzx ecx, byte ptr [rdi]
test cl, cl
jz .done
inc rdi
imul eax, eax, 33   ; hash = hash * 33
add eax, ecx        ; hash = hash + character
jmp .loop
.done:
ret
</code></pre>

<h2 id="control-flow-analysis">Control Flow Analysis</h2>

<p>Control flow analysis examines how execution moves through a program, identifying paths, loops, and conditional branches. This analysis is crucial for understanding program logic and behavior.</p>

<h3 id="basic-block-identification">Basic Block Identification</h3>

<p>A basic block is a sequence of instructions with a single entry point (the first instruction) and a single exit point (the last instruction). Control flow enters at the beginning and exits at the end without halting or branching except at the exit.</p>

<p>Identifying basic blocks involves:</p>
<ol>
  <li>Finding leaders (first instructions of basic blocks):
    <ul>
      <li>The first instruction of the program</li>
      <li>Instructions targeted by jumps</li>
      <li>Instructions following jumps or returns</li>
    </ul>
  </li>
  <li>Determining where each block ends (at jumps, returns, or before the next leader)</li>
</ol>

<pre><code class="language-assembly">; Basic block 1
mov eax, [rdi]
add eax, 5
cmp eax, 10
jg .label1      ; Exit point of block 1

; Basic block 2
mov ebx, 0
jmp .label2     ; Exit point of block 2

; Basic block 3 (.label1)
.label1:
mov ebx, 1

; Basic block 4 (.label2)
.label2:
ret             ; Exit point of blocks 3 and 4
</code></pre>

<h3 id="control-flow-graph-construction">Control Flow Graph Construction</h3>

<p>A Control Flow Graph (CFG) represents the program’s structure as a directed graph where:</p>
<ul>
  <li>Nodes are basic blocks</li>
  <li>Edges represent possible control flow between blocks</li>
</ul>

<p>Constructing a CFG involves:</p>
<ol>
  <li>Identifying all basic blocks</li>
  <li>Adding edges for all possible control transfers:
    <ul>
      <li>Sequential flow from one block to the next</li>
      <li>Conditional branches (two outgoing edges)</li>
      <li>Unconditional jumps</li>
      <li>Function calls (with edges to the called function and the return point)</li>
    </ul>
  </li>
</ol>

<p>Modern disassemblers like IDA Pro and Ghidra automatically generate CFGs, but understanding how to interpret and manually construct them is valuable for complex analysis.</p>

<h3 id="loop-detection">Loop Detection</h3>

<p>Loops are fundamental control structures that often represent important processing in a program. Detecting loops in a CFG involves finding cycles (paths that return to a previously visited node).</p>

<p>Common loop patterns include:</p>

<h4 id="counter-based-loops">Counter-Based Loops</h4>

<pre><code class="language-assembly">; Initialize counter
mov ecx, 10
.loop_start:
; Loop body
dec ecx
jnz .loop_start    ; Jump if not zero
</code></pre>

<h4 id="condition-based-loops">Condition-Based Loops</h4>

<pre><code class="language-assembly">.loop_start:
; Loop body
cmp byte ptr [rdi], 0
jne .loop_start    ; Continue until null byte
</code></pre>

<h4 id="nested-loops">Nested Loops</h4>

<pre><code class="language-assembly">; Outer loop initialization
mov ecx, 10
.outer_loop:
; Inner loop initialization
mov edx, 5
.inner_loop:
; Inner loop body
dec edx
jnz .inner_loop
; Outer loop continuation
dec ecx
jnz .outer_loop
</code></pre>

<p>Identifying loop structures helps understand the program’s algorithmic patterns and data processing logic.</p>

<h3 id="conditional-logic-recovery">Conditional Logic Recovery</h3>

<p>Recovering high-level conditional structures (if-then-else, switch-case) from assembly code requires analyzing branch patterns and their targets.</p>

<h4 id="if-then-else-structures">If-Then-Else Structures</h4>

<pre><code class="language-assembly">; if (condition) { then_block } else { else_block }
cmp eax, ebx
jne .else_branch
; Then block
...
jmp .end_if
.else_branch:
; Else block
...
.end_if:
</code></pre>

<h4 id="switch-case-structures">Switch-Case Structures</h4>

<p>Switch statements are typically implemented using jump tables or series of comparisons:</p>

<p><strong>Jump Table Implementation:</strong></p>
<pre><code class="language-assembly">; switch(value)
cmp eax, 5          ; Check upper bound
ja .default_case    ; If above, go to default
jmp [.jump_table + eax*4]  ; Jump based on value

.jump_table:
dd .case_0
dd .case_1
dd .case_2
dd .case_3
dd .case_4
dd .case_5

.case_0:
; Case 0 code
jmp .end_switch
.case_1:
; Case 1 code
jmp .end_switch
; ...
.default_case:
; Default case code
.end_switch:
</code></pre>

<p><strong>Comparison Chain Implementation:</strong></p>
<pre><code class="language-assembly">; switch(value) implemented as if-else chain
cmp eax, 0
je .case_0
cmp eax, 1
je .case_1
cmp eax, 2
je .case_2
; ...
jmp .default_case
</code></pre>

<p>Recognizing these patterns helps reconstruct the original high-level control structures.</p>

<h3 id="exception-handling-analysis">Exception Handling Analysis</h3>

<p>Exception handling mechanisms add complexity to control flow analysis. Different platforms use different approaches:</p>

<h4 id="windows-seh-structured-exception-handling">Windows SEH (Structured Exception Handling)</h4>

<p>Windows SEH uses registration records and exception handlers:</p>

<pre><code class="language-assembly">; SEH setup
push handler_address
push fs:[0]         ; Previous handler
mov fs:[0], esp     ; Register new handler

; Protected code
...

; SEH cleanup
pop fs:[0]          ; Restore previous handler
add esp, 4          ; Remove handler address
</code></pre>

<h4 id="c-exception-handling">C++ Exception Handling</h4>

<p>C++ exceptions typically use tables that map code regions to exception handlers:</p>

<pre><code class="language-assembly">; Function with C++ exception handling
.Ltry_start:
; Try block code
call potentially_throwing_function
.Ltry_end:
jmp .Lnormal_path

.Lcatch:
; Catch block code
...

.Lnormal_path:
; Continuation after try-catch
</code></pre>

<p>The actual implementation varies significantly between compilers and platforms, often using complex unwinding tables rather than explicit code like the simplified example above.</p>

<h2 id="data-flow-analysis">Data Flow Analysis</h2>

<p>Data flow analysis tracks how data values are created, modified, and used throughout a program. This analysis helps understand the program’s logic and identify important algorithms.</p>

<h3 id="use-definition-chains">Use-Definition Chains</h3>

<p>A use-definition (UD) chain links each use of a variable to all possible definitions (assignments) that could reach that use. In assembly analysis, this involves tracking register and memory values:</p>

<pre><code class="language-assembly">mov eax, 5          ; Definition of eax
add ebx, eax        ; Use of eax, definition of ebx
mov [rdi], ebx      ; Use of ebx, definition of memory at [rdi]
</code></pre>

<p>Constructing UD chains helps understand data dependencies and how values propagate through the program.</p>

<h3 id="taint-analysis">Taint Analysis</h3>

<p>Taint analysis tracks how “tainted” data (typically user input) flows through a program. This is particularly valuable for security analysis:</p>

<pre><code class="language-assembly">; Read user input into buffer at [rsp+16]
lea rcx, [rsp+16]   ; First parameter: buffer address
mov edx, 100        ; Second parameter: buffer size
call _read_input

; Use the input without validation
mov rax, [rsp+16]   ; Load first 8 bytes of input
call rax            ; Call address from user input (dangerous!)
</code></pre>

<p>Identifying such flows helps locate potential vulnerabilities like buffer overflows, format string vulnerabilities, or command injection.</p>

<h3 id="constant-propagation">Constant Propagation</h3>

<p>Constant propagation tracks known constant values through the program, which can simplify analysis by resolving computed values statically:</p>

<pre><code class="language-assembly">mov eax, 5          ; eax = 5
mov ebx, 3          ; ebx = 3
add eax, ebx        ; eax = 8
shl eax, 2          ; eax = 32
mov ecx, [eax+base] ; Access table at base+32
</code></pre>

<p>Knowing that <code class="language-plaintext highlighter-rouge">eax</code> contains 32 at the last instruction helps understand that the code is accessing a specific table entry.</p>

<h3 id="alias-analysis">Alias Analysis</h3>

<p>Alias analysis determines when different pointers might reference the same memory location. This is crucial for understanding memory access patterns:</p>

<pre><code class="language-assembly">mov rax, [rbp-8]    ; Load pointer from local variable
mov rcx, [rbp-16]   ; Load another pointer
mov [rax], 42       ; Write to first pointer
mov rdx, [rcx]      ; Read from second pointer - might read 42 if rax and rcx point to same location
</code></pre>

<p>Identifying potential aliases helps track data flow through memory and understand complex pointer manipulations.</p>

<h2 id="pattern-recognition-and-signature-matching">Pattern Recognition and Signature Matching</h2>

<p>Recognizing common code patterns dramatically accelerates reverse engineering by allowing you to identify known functionality rather than analyzing it from scratch.</p>

<h3 id="compiler-specific-patterns">Compiler-Specific Patterns</h3>

<p>Different compilers generate distinctive code patterns for common operations:</p>

<h4 id="function-prologues-and-epilogues">Function Prologues and Epilogues</h4>

<p><strong>MSVC x64:</strong></p>
<pre><code class="language-assembly">; Typical MSVC x64 function prologue
sub rsp, 40         ; Allocate stack space (with alignment)
mov [rsp+32], rbx   ; Save non-volatile registers
</code></pre>

<p><strong>GCC x64:</strong></p>
<pre><code class="language-assembly">; Typical GCC x64 function prologue
push rbp
mov rbp, rsp
push rbx            ; Save used callee-saved registers
sub rsp, 24         ; Allocate local variables (with alignment)
</code></pre>

<h4 id="memory-allocation">Memory Allocation</h4>

<p><strong>MSVC Heap Allocation:</strong></p>
<pre><code class="language-assembly">; malloc(size) in MSVC
mov rcx, size       ; First parameter: size
call malloc
</code></pre>

<p><strong>GCC Heap Allocation:</strong></p>
<pre><code class="language-assembly">; malloc(size) in GCC
mov rdi, size       ; First parameter: size
call malloc@PLT
</code></pre>

<h3 id="standard-library-function-signatures">Standard Library Function Signatures</h3>

<p>Standard library functions have characteristic patterns that can be recognized even when symbol information is stripped:</p>

<h4 id="string-functions">String Functions</h4>

<p><strong>strlen implementation:</strong></p>
<pre><code class="language-assembly">; Simplified strlen pattern
xor eax, eax        ; Initialize counter/index
.loop:
cmp byte ptr [rdi+rax], 0  ; Check for null terminator
je .done
inc rax
jmp .loop
.done:
ret                 ; Return length in eax
</code></pre>

<p><strong>memcpy implementation:</strong></p>
<pre><code class="language-assembly">; Simplified memcpy pattern
xor eax, eax        ; Initialize counter/index
.loop:
cmp rax, rdx        ; Compare counter with size
jge .done
mov cl, [rsi+rax]   ; Read byte from source
mov [rdi+rax], cl   ; Write byte to destination
inc rax
jmp .loop
.done:
mov rax, rdi        ; Return destination pointer
ret
</code></pre>

<h4 id="memory-management">Memory Management</h4>

<p><strong>malloc/free patterns</strong> often involve specific interactions with heap management functions and data structures.</p>

<h4 id="io-operations">I/O Operations</h4>

<p><strong>File operations</strong> like open, read, write have distinctive parameter patterns and system call usage.</p>

<h3 id="cryptographic-algorithm-detection">Cryptographic Algorithm Detection</h3>

<p>Cryptographic algorithms have distinctive characteristics that make them recognizable:</p>

<h4 id="constant-tables">Constant Tables</h4>

<p>Many cryptographic algorithms use predefined constant tables:</p>

<pre><code class="language-assembly">; AES S-box lookup
movzx eax, byte ptr [rdi]   ; Get input byte
mov al, [.sbox + rax]       ; Look up substitution

.sbox:
db 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, ...
</code></pre>

<h4 id="bitwise-operations">Bitwise Operations</h4>

<p>Cryptographic algorithms typically use extensive bitwise operations:</p>

<pre><code class="language-assembly">; SHA-256 round operations (simplified)
mov eax, [rdi+0]    ; Load state word
ror eax, 2
xor eax, [rdi+0]
ror eax, 11
xor eax, [rdi+0]
ror eax, 7
</code></pre>

<h4 id="block-processing-loops">Block Processing Loops</h4>

<p>Many algorithms process data in fixed-size blocks with multiple rounds:</p>

<pre><code class="language-assembly">; Block cipher processing loop
mov rcx, [rbp-8]    ; Load block count
test rcx, rcx
jz .done
.block_loop:
; Process one block
...
dec rcx
jnz .block_loop
</code></pre>

<h3 id="data-structure-recognition">Data Structure Recognition</h3>

<p>Identifying common data structures helps understand how a program organizes and processes information.</p>

<h4 id="linked-lists">Linked Lists</h4>

<p>Linked list traversal has a characteristic pattern:</p>

<pre><code class="language-assembly">; Linked list traversal
mov rax, [list_head]  ; Start with head pointer
.loop:
test rax, rax       ; Check for null (end of list)
jz .done
; Process node
mov rdi, [rax+8]    ; Access node data
call process_data
; Move to next node
mov rax, [rax]      ; rax = rax-&gt;next
jmp .loop
</code></pre>

<h4 id="trees">Trees</h4>

<p>Tree traversal often involves recursion or an explicit stack:</p>

<pre><code class="language-assembly">; Binary tree traversal (recursive, simplified)
; rdi = node pointer
traverse_tree:
test rdi, rdi       ; Check for null node
jz .return

; Process current node
push rdi
call process_node

; Traverse left subtree
mov rdi, [rdi+8]    ; rdi = node-&gt;left
call traverse_tree

; Traverse right subtree
pop rdi             ; Restore current node
mov rdi, [rdi+16]   ; rdi = node-&gt;right
call traverse_tree

.return:
ret
</code></pre>

<h4 id="hash-tables">Hash Tables</h4>

<p>Hash table operations involve hash computation followed by bucket access:</p>

<pre><code class="language-assembly">; Hash table lookup (simplified)
; rdi = hash table, rsi = key
mov rdx, rsi        ; Copy key for hashing
call compute_hash   ; Hash function returns hash in eax
and eax, [rdi+8]    ; Mask with table size-1 (assuming power of 2)
shl eax, 4          ; Multiply by entry size (e.g., 16 bytes)
add rax, [rdi+16]   ; Add bucket array base address
; Now rax points to the bucket
</code></pre>

<h2 id="advanced-static-analysis-techniques">Advanced Static Analysis Techniques</h2>

<p>Beyond the fundamental approaches, several advanced techniques can provide deeper insights into program behavior.</p>

<h3 id="symbolic-execution">Symbolic Execution</h3>

<p>Symbolic execution analyzes a program by tracking symbolic rather than concrete values. Instead of executing with specific inputs, it represents inputs as symbols and builds expressions that describe how outputs relate to inputs.</p>

<p>For example, consider this simple function:</p>

<pre><code class="language-assembly">; int abs(int x)
; x in edi
abs_function:
  mov eax, edi      ; eax = x
  test eax, eax     ; Set flags based on x
  jge .positive     ; Jump if x &gt;= 0
  neg eax           ; eax = -eax (if x &lt; 0)
.positive:
  ret               ; Return eax
</code></pre>

<p>Symbolic execution would track:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">eax = X</code> (symbolic input)</li>
  <li>If <code class="language-plaintext highlighter-rouge">X &gt;= 0</code>, then result is <code class="language-plaintext highlighter-rouge">X</code></li>
  <li>If <code class="language-plaintext highlighter-rouge">X &lt; 0</code>, then result is <code class="language-plaintext highlighter-rouge">-X</code></li>
  <li>Therefore, the function returns <code class="language-plaintext highlighter-rouge">|X|</code> (absolute value)</li>
</ol>

<p>Tools like KLEE, angr, and Triton provide symbolic execution capabilities for binary analysis.</p>

<h3 id="value-set-analysis">Value Set Analysis</h3>

<p>Value Set Analysis (VSA) tracks the possible values of registers and memory locations at each program point. Unlike concrete execution, which tracks single values, VSA tracks sets or ranges of values.</p>

<p>For example:</p>

<pre><code class="language-assembly">mov eax, [user_input]  ; Load user input
and eax, 3             ; Mask with 3
</code></pre>

<p>VSA would determine that after these instructions, <code class="language-plaintext highlighter-rouge">eax</code> must be in the set {0, 1, 2, 3}, regardless of the input value.</p>

<p>This analysis helps understand program constraints and identify unreachable code paths.</p>

<h3 id="type-reconstruction">Type Reconstruction</h3>

<p>Type reconstruction infers data types from usage patterns, helping bridge the gap between assembly and higher-level understanding.</p>

<p>Advanced type reconstruction considers:</p>

<h4 id="size-based-inference">Size-Based Inference</h4>

<pre><code class="language-assembly">mov eax, [rdi]      ; 4-byte access suggests int or float
movzx ecx, byte ptr [rdi+4]  ; 1-byte access suggests char or bool
</code></pre>

<h4 id="operation-based-inference">Operation-Based Inference</h4>

<pre><code class="language-assembly">; Pointer arithmetic
shl rsi, 3          ; Multiply index by 8
add rsi, [rbp-16]   ; Add to base address
mov rax, [rsi]      ; Access array of 8-byte elements

; Floating-point operations
movss xmm0, [rdi]   ; Load as float
addss xmm0, xmm1    ; Float addition
</code></pre>

<h4 id="field-access-patterns">Field Access Patterns</h4>

<pre><code class="language-assembly">; Structure field access pattern
mov rax, [rdi]      ; Access field at offset 0
mov rcx, [rdi+8]    ; Access field at offset 8
mov rdx, [rdi+16]   ; Access field at offset 16
</code></pre>

<p>By combining these inferences, type reconstruction can produce C-like struct definitions and variable types that make the disassembly more readable.</p>

<h3 id="decompilation">Decompilation</h3>

<p>Decompilation is the process of converting assembly code back to a higher-level representation, typically C-like pseudocode. Modern decompilers like Hex-Rays, Ghidra’s decompiler, and RetDec perform sophisticated analysis to recover source-like code.</p>

<p>The decompilation process typically involves:</p>

<ol>
  <li><strong>Control flow analysis</strong>: Identifying basic blocks and control structures</li>
  <li><strong>Data flow analysis</strong>: Tracking variable definitions and uses</li>
  <li><strong>Type analysis</strong>: Inferring variable and function types</li>
  <li><strong>Structure recovery</strong>: Reconstructing loops, conditionals, and switch statements</li>
  <li><strong>Expression propagation</strong>: Combining operations into higher-level expressions</li>
</ol>

<p>For example, this assembly code:</p>

<pre><code class="language-assembly">mov eax, [rdi]      ; Load first element
mov ecx, [rdi+4]    ; Load second element
add eax, ecx        ; Add them
mov ecx, [rdi+8]    ; Load third element
imul ecx            ; Multiply by third element
ret                 ; Return result
</code></pre>

<p>Might decompile to:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Decompilers significantly accelerate reverse engineering but aren’t perfect. They may produce confusing or incorrect output for complex code, optimized binaries, or unusual programming patterns. Understanding assembly remains essential for verifying and correcting decompiler output.</p>

<h2 id="practical-static-analysis-workflows">Practical Static Analysis Workflows</h2>

<p>Let’s explore practical workflows for applying static analysis techniques to real-world reverse engineering tasks.</p>

<h3 id="initial-binary-reconnaissance">Initial Binary Reconnaissance</h3>

<p>Before diving into detailed analysis, gather basic information about the binary:</p>

<ol>
  <li><strong>Identify the file type and architecture</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>file binary
binary: ELF 64-bit LSB executable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="k">for </span>GNU/Linux 3.2.0, BuildID[sha1]<span class="o">=</span>0123456789abcdef, stripped
</code></pre></div>    </div>
  </li>
  <li><strong>Check for symbols and sections</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nm binary
nm: binary: no symbols
<span class="nv">$ </span>readelf <span class="nt">-S</span> binary
<span class="o">[</span>Section headers output...]
</code></pre></div>    </div>
  </li>
  <li><strong>Identify imported and exported functions</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>objdump <span class="nt">-T</span> binary
<span class="o">[</span>Dynamic symbol table output...]
</code></pre></div>    </div>
  </li>
  <li><strong>Examine strings for clues</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>strings binary | <span class="nb">grep</span> <span class="nt">-i</span> password
Enter password:
Password incorrect
</code></pre></div>    </div>
  </li>
</ol>

<p>This initial reconnaissance helps focus your analysis on promising areas.</p>

<h3 id="function-identification-and-prioritization">Function Identification and Prioritization</h3>

<p>With the binary loaded in a disassembler:</p>

<ol>
  <li><strong>Review automatically identified functions</strong>
    <ul>
      <li>Check the function list in IDA Pro, Ghidra, or Binary Ninja</li>
      <li>Look for descriptive names or patterns in unnamed functions</li>
    </ul>
  </li>
  <li><strong>Identify key functions based on cross-references</strong>
    <ul>
      <li>Functions referenced by the entry point</li>
      <li>Functions that reference interesting strings</li>
      <li>Functions that call important APIs (file, network, crypto)</li>
    </ul>
  </li>
  <li><strong>Prioritize functions for analysis</strong>
    <ul>
      <li>Start with the main function or program entry point</li>
      <li>Focus on functions that handle user input or sensitive operations</li>
      <li>Defer analysis of library or utility functions</li>
    </ul>
  </li>
</ol>

<h3 id="iterative-function-analysis">Iterative Function Analysis</h3>

<p>For each prioritized function:</p>

<ol>
  <li><strong>Examine function signature and frame</strong>
    <ul>
      <li>Identify parameters and return value</li>
      <li>Note local variable usage</li>
    </ul>
  </li>
  <li><strong>Analyze control flow</strong>
    <ul>
      <li>Review the control flow graph</li>
      <li>Identify loops and conditional branches</li>
      <li>Understand the high-level structure</li>
    </ul>
  </li>
  <li><strong>Track key data flows</strong>
    <ul>
      <li>Follow user input through the function</li>
      <li>Track how return values are calculated</li>
      <li>Identify important memory accesses</li>
    </ul>
  </li>
  <li><strong>Annotate the disassembly</strong>
    <ul>
      <li>Rename variables and functions meaningfully</li>
      <li>Add comments explaining complex logic</li>
      <li>Create structure definitions for data types</li>
    </ul>
  </li>
  <li><strong>Review decompiler output</strong>
    <ul>
      <li>Compare with your assembly analysis</li>
      <li>Correct any obvious decompiler errors</li>
      <li>Refine your understanding based on the higher-level view</li>
    </ul>
  </li>
</ol>

<h3 id="algorithm-identification">Algorithm Identification</h3>

<p>When you suspect a function implements a known algorithm:</p>

<ol>
  <li><strong>Look for telltale constants</strong>
    <ul>
      <li>Cryptographic algorithms often use specific initialization values or tables</li>
      <li>Hashing functions typically have distinctive constants</li>
    </ul>
  </li>
  <li><strong>Analyze the overall structure</strong>
    <ul>
      <li>Block processing loops</li>
      <li>Round functions</li>
      <li>Characteristic transformations</li>
    </ul>
  </li>
  <li><strong>Compare with reference implementations</strong>
    <ul>
      <li>Compile known algorithms and compare the assembly</li>
      <li>Check for matching patterns in cryptographic libraries</li>
    </ul>
  </li>
  <li><strong>Test hypotheses with sample inputs</strong>
    <ul>
      <li>If possible, run the function with known inputs</li>
      <li>Compare results with reference implementations</li>
    </ul>
  </li>
</ol>

<h3 id="collaborative-and-iterative-analysis">Collaborative and Iterative Analysis</h3>

<p>Complex binaries benefit from collaborative and iterative analysis:</p>

<ol>
  <li><strong>Divide and conquer</strong>
    <ul>
      <li>Assign different modules or functions to different analysts</li>
      <li>Share findings regularly</li>
    </ul>
  </li>
  <li><strong>Build a knowledge base</strong>
    <ul>
      <li>Document identified functions and algorithms</li>
      <li>Create a dictionary of program-specific terms and structures</li>
    </ul>
  </li>
  <li><strong>Iteratively refine understanding</strong>
    <ul>
      <li>Revisit previously analyzed functions with new insights</li>
      <li>Update annotations and documentation</li>
    </ul>
  </li>
  <li><strong>Combine static and dynamic analysis</strong>
    <ul>
      <li>Use dynamic analysis to verify static findings</li>
      <li>Update static analysis based on runtime observations</li>
    </ul>
  </li>
</ol>

<h2 id="case-studies-in-static-analysis">Case Studies in Static Analysis</h2>

<p>Let’s examine two case studies that demonstrate static analysis techniques in action.</p>

<h3 id="case-study-1-identifying-a-custom-encryption-routine">Case Study 1: Identifying a Custom Encryption Routine</h3>

<p>Consider this simplified assembly function from a proprietary file format parser:</p>

<pre><code class="language-assembly">custom_encrypt:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    sub rsp, 16
    
    ; Parameters: rdi = input buffer, rsi = output buffer, rdx = length, rcx = key
    mov r12, rdi        ; r12 = input buffer
    mov r13, rsi        ; r13 = output buffer
    mov rbx, rdx        ; rbx = length
    mov [rbp-16], rcx   ; Store key on stack
    
    ; Initialize counter
    xor rax, rax
    
.loop:
    ; Check if we've processed all bytes
    cmp rax, rbx
    jge .done
    
    ; Load input byte
    movzx edx, byte ptr [r12+rax]
    
    ; XOR with key byte (key is 4 bytes, so we cycle through it)
    mov rcx, rax
    and rcx, 3          ; rcx = rax % 4
    movzx ecx, byte ptr [rbp-16+rcx]  ; Load key byte
    xor edx, ecx        ; XOR input byte with key byte
    
    ; Substitute through S-box
    lea rsi, [rip+.sbox]
    movzx edx, byte ptr [rsi+rdx]  ; Substitute
    
    ; Store encrypted byte
    mov [r13+rax], dl
    
    ; Increment counter and continue
    inc rax
    jmp .loop
    
.done:
    add rsp, 16
    pop r13
    pop r12
    pop rbx
    pop rbp
    ret
    
.sbox:
    db 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76
    db 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0
    ; ... rest of S-box (256 bytes total)
</code></pre>

<p><strong>Static Analysis Approach:</strong></p>

<ol>
  <li><strong>Function Signature Analysis</strong>
    <ul>
      <li>Four parameters: input buffer, output buffer, length, key</li>
      <li>No return value (void function)</li>
    </ul>
  </li>
  <li><strong>Control Flow Analysis</strong>
    <ul>
      <li>Single loop processing each byte</li>
      <li>No complex branching</li>
    </ul>
  </li>
  <li><strong>Algorithm Identification</strong>
    <ul>
      <li>XOR operation with cycling key bytes</li>
      <li>Substitution using a 256-byte table</li>
      <li>The S-box values match the AES S-box</li>
    </ul>
  </li>
  <li><strong>Conclusion</strong>
    <ul>
      <li>This is a simple substitution-permutation cipher</li>
      <li>It uses XOR with a 4-byte key followed by AES S-box substitution</li>
      <li>Not cryptographically strong (short key, no diffusion)</li>
    </ul>
  </li>
</ol>

<p>With this understanding, we can document the algorithm and potentially create a decryption routine by reversing the operations.</p>

<h3 id="case-study-2-reconstructing-a-proprietary-file-format">Case Study 2: Reconstructing a Proprietary File Format</h3>

<p>Consider this function that parses a file header:</p>

<pre><code class="language-assembly">parse_file_header:
    push rbp
    mov rbp, rsp
    sub rsp, 32
    
    ; rdi = file handle, rsi = header struct pointer
    mov [rbp-8], rdi    ; Store file handle
    mov [rbp-16], rsi   ; Store header struct pointer
    
    ; Read magic number (4 bytes)
    mov rdi, [rbp-8]    ; File handle
    mov rsi, [rbp-16]   ; Header struct (first field is magic)
    mov rdx, 4          ; Read 4 bytes
    call read_file
    cmp rax, 4
    jne .error_invalid
    
    ; Check magic number "MYFF"
    mov rsi, [rbp-16]
    cmp dword ptr [rsi], 0x4646594d  ; "MYFF" in little-endian
    jne .error_invalid
    
    ; Read version (2 bytes)
    mov rdi, [rbp-8]
    lea rsi, [rbp-16+4]  ; Header struct + 4 (version field)
    mov rdx, 2
    call read_file
    cmp rax, 2
    jne .error_invalid
    
    ; Read flags (2 bytes)
    mov rdi, [rbp-8]
    lea rsi, [rbp-16+6]  ; Header struct + 6 (flags field)
    mov rdx, 2
    call read_file
    cmp rax, 2
    jne .error_invalid
    
    ; Read entry count (4 bytes)
    mov rdi, [rbp-8]
    lea rsi, [rbp-16+8]  ; Header struct + 8 (entry_count field)
    mov rdx, 4
    call read_file
    cmp rax, 4
    jne .error_invalid
    
    ; Read timestamp (8 bytes)
    mov rdi, [rbp-8]
    lea rsi, [rbp-16+12]  ; Header struct + 12 (timestamp field)
    mov rdx, 8
    call read_file
    cmp rax, 8
    jne .error_invalid
    
    ; Success
    mov eax, 1
    jmp .done
    
.error_invalid:
    xor eax, eax
    
.done:
    leave
    ret
</code></pre>

<p><strong>Static Analysis Approach:</strong></p>

<ol>
  <li><strong>Function Signature Analysis</strong>
    <ul>
      <li>Two parameters: file handle and header struct pointer</li>
      <li>Returns 1 on success, 0 on error</li>
    </ul>
  </li>
  <li><strong>Data Structure Analysis</strong>
    <ul>
      <li>Sequential reads into different offsets of the header struct</li>
      <li>Field sizes and offsets reveal the structure layout</li>
    </ul>
  </li>
  <li><strong>File Format Reconstruction</strong>
    <ul>
      <li>Magic number: “MYFF” (4 bytes)</li>
      <li>Version: 2 bytes</li>
      <li>Flags: 2 bytes</li>
      <li>Entry count: 4 bytes</li>
      <li>Timestamp: 8 bytes</li>
      <li>Total header size: 20 bytes</li>
    </ul>
  </li>
  <li><strong>Conclusion</strong>
    <ul>
      <li>We can reconstruct the header struct definition:
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">file_header</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">magic</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>      <span class="c1">// "MYFF"</span>
    <span class="kt">uint16_t</span> <span class="n">version</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">entry_count</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<p>This analysis allows us to understand the file format and potentially create tools to parse or generate compatible files.</p>

<h2 id="challenges-and-limitations-of-static-analysis">Challenges and Limitations of Static Analysis</h2>

<p>While powerful, static analysis faces several challenges and limitations:</p>

<h3 id="obfuscation-techniques">Obfuscation Techniques</h3>

<p>Code obfuscation deliberately makes static analysis difficult through techniques like:</p>

<ul>
  <li><strong>Control flow obfuscation</strong>: Adding spurious branches and jumps</li>
  <li><strong>Opaque predicates</strong>: Conditions that always evaluate the same way but are difficult to determine statically</li>
  <li><strong>Instruction substitution</strong>: Replacing simple operations with complex equivalents</li>
  <li><strong>Dead code insertion</strong>: Adding code that never executes</li>
  <li><strong>String encryption</strong>: Encrypting strings and decrypting them at runtime</li>
</ul>

<p>These techniques can significantly slow down analysis and require combining static and dynamic approaches.</p>

<h3 id="anti-disassembly-tricks">Anti-Disassembly Tricks</h3>

<p>Some binaries employ anti-disassembly techniques that cause disassemblers to produce incorrect output:</p>

<ul>
  <li><strong>Overlapping instructions</strong>: Creating valid instruction sequences that can be interpreted differently depending on the entry point</li>
  <li><strong>Data in code sections</strong>: Inserting data bytes that disassemblers misinterpret as instructions</li>
  <li><strong>Self-modifying code</strong>: Code that changes itself at runtime</li>
  <li><strong>Junk byte insertion</strong>: Adding bytes that cause disassembly to go out of sync</li>
</ul>

<p>Recognizing these techniques requires experience and careful analysis.</p>

<h3 id="indirect-jumps-and-calls">Indirect Jumps and Calls</h3>

<p>Indirect control flow through function pointers, virtual methods, or jump tables complicates static analysis:</p>

<pre><code class="language-assembly">; Indirect call through function pointer
mov rax, [rdi+8]    ; Load function pointer
call rax            ; Call through pointer

; Jump table
mov eax, [rdi]      ; Load index
cmp eax, 5          ; Bounds check
ja .default
jmp [.table+rax*8]  ; Jump based on index
</code></pre>

<p>These constructs make it difficult to determine all possible execution paths statically.</p>

<h3 id="dynamic-code-generation">Dynamic Code Generation</h3>

<p>Some programs generate or modify code at runtime, which is invisible to static analysis:</p>

<ul>
  <li>JIT (Just-In-Time) compilation</li>
  <li>Runtime code patching</li>
  <li>Self-extracting or self-decrypting code</li>
</ul>

<p>These techniques require dynamic analysis to fully understand.</p>

<h3 id="limitations-of-decompilers">Limitations of Decompilers</h3>

<p>Decompilers have inherent limitations:</p>

<ul>
  <li><strong>Type recovery limitations</strong>: Complex types may not be accurately reconstructed</li>
  <li><strong>Optimized code challenges</strong>: Heavily optimized code may decompile to confusing output</li>
  <li><strong>Custom calling conventions</strong>: Non-standard parameter passing can confuse decompilers</li>
  <li><strong>Inline assembly</strong>: Assembly blocks in the original code may not decompile cleanly</li>
</ul>

<p>Always verify decompiler output against the assembly for critical code sections.</p>

<h2 id="tools-for-static-analysis">Tools for Static Analysis</h2>

<p>Numerous tools support static binary analysis, each with different strengths:</p>

<h3 id="disassemblers-and-decompilers">Disassemblers and Decompilers</h3>

<ul>
  <li><strong>IDA Pro</strong>: Industry-standard disassembler with powerful analysis capabilities and the Hex-Rays decompiler</li>
  <li><strong>Ghidra</strong>: NSA-developed open-source disassembler and decompiler with advanced features</li>
  <li><strong>Binary Ninja</strong>: Modern disassembler with a focus on API and extensibility</li>
  <li><strong>Radare2/Cutter</strong>: Open-source disassembly framework with a growing feature set</li>
  <li><strong>RetDec</strong>: Open-source retargetable decompiler</li>
</ul>

<h3 id="specialized-analysis-tools">Specialized Analysis Tools</h3>

<ul>
  <li><strong>angr</strong>: Python framework for binary analysis with symbolic execution capabilities</li>
  <li><strong>BARF</strong>: Binary Analysis and Reverse engineering Framework</li>
  <li><strong>Triton</strong>: Dynamic Binary Analysis framework for building program analysis tools</li>
  <li><strong>Capstone</strong>: Lightweight multi-platform, multi-architecture disassembly framework</li>
  <li><strong>Snowman</strong>: Native code to C/C++ decompiler</li>
</ul>

<h3 id="static-analysis-frameworks">Static Analysis Frameworks</h3>

<ul>
  <li><strong>BAP (Binary Analysis Platform)</strong>: OCaml framework for binary analysis</li>
  <li><strong>Pharos</strong>: Framework for automated static analysis of binaries</li>
  <li><strong>CodeSurfer</strong>: Program understanding and analysis tool</li>
  <li><strong>Jakstab</strong>: Abstract Interpretation-based static analysis for binaries</li>
</ul>

<h3 id="visualization-tools">Visualization Tools</h3>

<ul>
  <li><strong>Gephi</strong>: Graph visualization for complex control flow analysis</li>
  <li><strong>GraphViz</strong>: Graph visualization used by many analysis tools</li>
  <li><strong>Visjs</strong>: JavaScript visualization library useful for web-based analysis tools</li>
</ul>

<h2 id="summary">Summary</h2>

<p>Static code analysis is a powerful approach for understanding program behavior without execution. In this chapter, we’ve explored techniques for analyzing binary code at multiple levels:</p>

<ul>
  <li><strong>Function analysis</strong>: Identifying functions, their signatures, and their purposes</li>
  <li><strong>Control flow analysis</strong>: Understanding how execution moves through the program</li>
  <li><strong>Data flow analysis</strong>: Tracking how data is transformed and propagated</li>
  <li><strong>Pattern recognition</strong>: Identifying common algorithms and library code</li>
  <li><strong>Advanced techniques</strong>: Using symbolic execution, type reconstruction, and decompilation</li>
</ul>

<p>Effective static analysis combines these techniques with a systematic workflow, moving from initial reconnaissance to detailed function analysis and algorithm identification. While static analysis has limitations, particularly when facing obfuscation or dynamic code generation, it remains a fundamental approach in the reverse engineer’s toolkit.</p>

<p>In the next chapter, we’ll explore dynamic analysis techniques that complement static analysis by observing program behavior during execution.</p>

<h2 id="exercises">Exercises</h2>

<ol>
  <li>
    <p><strong>Function Signature Recovery</strong>: Choose a stripped binary (with no debugging symbols) and select three functions. Using only static analysis, determine each function’s parameters, return value, and purpose. Document your reasoning process.</p>
  </li>
  <li>
    <p><strong>Control Flow Analysis</strong>: Find a function with complex control flow in a binary of your choice. Draw its control flow graph manually, identifying loops, conditional branches, and exception handling. Compare your manual analysis with the graph generated by a tool like IDA Pro or Ghidra.</p>
  </li>
  <li>
    <p><strong>Algorithm Identification</strong>: Locate a cryptographic function in an open-source binary (e.g., OpenSSL, GnuPG). Using static analysis, identify which algorithm it implements and key characteristics that led to your conclusion.</p>
  </li>
  <li>
    <p><strong>Data Structure Reconstruction</strong>: Find a binary that processes a structured file format. Through static analysis of its parsing functions, reconstruct the file format’s structure and document it as C struct definitions.</p>
  </li>
</ol>


  </div>

  <nav class="chapter-navigation">
    
    <a href="/inside-the-machine/chapters/chapter-05-assembly-language-basics/" class="prev">&laquo; Chapter 5: Assembly Language Basics</a>
    
    
    <a href="/inside-the-machine/chapters" class="toc">Table of Contents</a>
    
    
    <a href="/inside-the-machine/chapters/chapter-07-debugging-fundamentals/" class="next">Chapter 7: Debugging Fundamentals &raquo;</a>
    
  </nav>
</article>
  </main>

  <footer class="site-footer">
  <div class="container">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Inside the Machine</h2>
        <p>A comprehensive guide to the art of reverse engineering, exploring various techniques and strategies to extract valuable insights from software systems.
</p>
      </div>

      <div class="footer-col">
        <h2 class="footer-heading">Contact</h2>
        <ul class="contact-list">
          <li><a href="mailto:immadmohit@gmail.com">immadmohit@gmail.com</a></li>
          <li><a href="https://github.com/mohitmishra786">GitHub</a></li>
        </ul>
      </div>

      <div class="footer-col">
        <h2 class="footer-heading">Quick Links</h2>
        <ul class="page-list">
          <li><a href="/inside-the-machine/">Home</a></li>
          <li><a href="/inside-the-machine/chapters">Chapters</a></li>
          <li><a href="/inside-the-machine/about">About</a></li>
        </ul>
      </div>
    </div>

    <div class="copyright">
      <p>&copy; 2025 Mohit Mishra. All rights reserved.</p>
    </div>
  </div>
</footer>
  
  <script src="/inside-the-machine/assets/js/theme-toggle.js"></script>
</body>
</html>