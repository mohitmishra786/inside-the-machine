<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inside the Machine | A Practical Approach to Reverse Engineering for Developers</title>
  <link rel="stylesheet" href="/inside-the-machine/assets/css/main.css">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Inside the Machine" />
<meta name="author" content="Mohit Mishra" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A comprehensive guide to the art of reverse engineering, exploring various techniques and strategies to extract valuable insights from software systems." />
<meta property="og:description" content="A comprehensive guide to the art of reverse engineering, exploring various techniques and strategies to extract valuable insights from software systems." />
<link rel="canonical" href="https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-05-assembly-language-basics/" />
<meta property="og:url" content="https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-05-assembly-language-basics/" />
<meta property="og:site_name" content="Inside the Machine" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-27T18:24:37+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Inside the Machine" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mohit Mishra"},"dateModified":"2025-04-27T18:24:37+00:00","datePublished":"2025-04-27T18:24:37+00:00","description":"A comprehensive guide to the art of reverse engineering, exploring various techniques and strategies to extract valuable insights from software systems.","headline":"Inside the Machine","mainEntityOfPage":{"@type":"WebPage","@id":"https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-05-assembly-language-basics/"},"url":"https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-05-assembly-language-basics/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
  <div class="container">
    <a href="/inside-the-machine/" class="site-title">Inside the Machine</a>
    
    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
          </svg>
        </span>
      </label>

      <div class="trigger">
        <a class="page-link" href="/inside-the-machine/chapters">Chapters</a>
        <a class="page-link" href="/inside-the-machine/about">About</a>
        <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
          <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
          </svg>
          <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
        </button>
      </div>
    </nav>
  </div>
</header>
  
  <main class="container">
    <article class="chapter">
  <header class="chapter-header">
    <h1></h1>
    
  </header>

  <div class="chapter-content">
    <p><em>Part 2: Disassembly and Analysis</em></p>

<p>In this chapter, we’ll build a foundation for understanding assembly language across different architectures. Rather than attempting to be a comprehensive reference, we’ll focus on the core concepts and patterns that will help you make sense of disassembled code in real-world reverse engineering scenarios.</p>

<h2 id="understanding-the-cpu-architecture-model">Understanding the CPU Architecture Model</h2>

<p>Before diving into assembly language itself, we need to understand the computational model that underlies it. Modern CPUs, despite their differences, share common architectural elements that assembly language directly manipulates.</p>

<h3 id="registers">Registers</h3>

<p>Registers are small, high-speed storage locations built directly into the CPU. They serve as the primary working space for the processor, holding operands for calculations, memory addresses, program counters, and other critical values.</p>

<p>The number, size, and purpose of registers vary by architecture, but most CPUs include:</p>

<ul>
  <li><strong>General-purpose registers</strong>: Used for arithmetic, data movement, and addressing</li>
  <li><strong>Program counter/instruction pointer</strong>: Points to the next instruction to execute</li>
  <li><strong>Stack pointer</strong>: Manages the program stack</li>
  <li><strong>Status/flags register</strong>: Contains bits that reflect the results of operations (zero, negative, overflow, etc.)</li>
  <li><strong>Specialized registers</strong>: May include base pointers, segment registers, vector registers, etc.</li>
</ul>

<p>Registers are the most frequently referenced elements in assembly code, so understanding their roles in a particular architecture is essential.</p>

<h3 id="memory-model">Memory Model</h3>

<p>Assembly language operates within the CPU’s memory model, which typically includes:</p>

<ul>
  <li><strong>Flat memory space</strong>: Modern architectures generally use a single, continuous address space</li>
  <li><strong>Stack</strong>: A region of memory that grows and shrinks in a last-in, first-out manner, used for local variables, function parameters, return addresses, and register preservation</li>
  <li><strong>Heap</strong>: Dynamically allocated memory</li>
  <li><strong>Code/data segments</strong>: Regions containing program instructions and data</li>
</ul>

<p>Assembly instructions frequently reference memory locations, either directly by address or indirectly through registers and offsets.</p>

<h3 id="instruction-set">Instruction Set</h3>

<p>The instruction set defines the operations a CPU can perform. While instruction sets vary between architectures, they typically include:</p>

<ul>
  <li><strong>Data movement</strong>: Transferring data between registers and memory</li>
  <li><strong>Arithmetic</strong>: Addition, subtraction, multiplication, division</li>
  <li><strong>Logical operations</strong>: AND, OR, XOR, NOT</li>
  <li><strong>Comparison</strong>: Testing values against each other</li>
  <li><strong>Control flow</strong>: Conditional and unconditional jumps, calls, and returns</li>
  <li><strong>Stack manipulation</strong>: Push and pop operations</li>
  <li><strong>Special instructions</strong>: System calls, interrupts, privileged operations</li>
</ul>

<p>Each instruction in the set has a mnemonic (a short, symbolic name) that assembly language uses to represent it.</p>

<h2 id="x86-and-x86-64-architecture">x86 and x86-64 Architecture</h2>

<p>The x86 architecture (and its 64-bit extension, x86-64) is one of the most common targets for reverse engineering due to its prevalence in desktop and server computing. Let’s explore its key characteristics.</p>

<h3 id="register-set">Register Set</h3>

<h4 id="32-bit-x86-registers">32-bit x86 Registers</h4>

<p>The 32-bit x86 architecture includes eight general-purpose registers:</p>

<ul>
  <li><strong>EAX</strong>: Accumulator, often used for arithmetic operations and function return values</li>
  <li><strong>EBX</strong>: Base register, sometimes used for memory addressing</li>
  <li><strong>ECX</strong>: Counter register, used for loop counters and shifts</li>
  <li><strong>EDX</strong>: Data register, used for I/O and some arithmetic operations</li>
  <li><strong>ESI</strong>: Source index for string operations</li>
  <li><strong>EDI</strong>: Destination index for string operations</li>
  <li><strong>ESP</strong>: Stack pointer, points to the top of the stack</li>
  <li><strong>EBP</strong>: Base pointer, typically points to the stack frame</li>
</ul>

<p>Special registers include:</p>

<ul>
  <li><strong>EIP</strong>: Instruction pointer, points to the next instruction</li>
  <li><strong>EFLAGS</strong>: Status flags register</li>
</ul>

<p>Segment registers (CS, DS, SS, ES, FS, GS) are also available but less commonly used in modern code.</p>

<h4 id="64-bit-x86-64-registers">64-bit x86-64 Registers</h4>

<p>The x86-64 architecture extends the register set to 16 general-purpose 64-bit registers:</p>

<ul>
  <li><strong>RAX, RBX, RCX, RDX</strong>: 64-bit extensions of the original registers</li>
  <li><strong>RSI, RDI</strong>: 64-bit extensions of the index registers</li>
  <li><strong>RSP, RBP</strong>: 64-bit extensions of the stack and base pointers</li>
  <li><strong>R8-R15</strong>: Eight additional general-purpose registers</li>
</ul>

<p>The instruction pointer becomes RIP, and the flags register becomes RFLAGS.</p>

<p>Importantly, portions of these registers can be accessed separately:</p>

<ul>
  <li><strong>RAX</strong> (64-bit full register)
    <ul>
      <li><strong>EAX</strong> (lower 32 bits)
        <ul>
          <li><strong>AX</strong> (lower 16 bits)
            <ul>
              <li><strong>AL</strong> (lower 8 bits)</li>
              <li><strong>AH</strong> (upper 8 bits of AX)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>This register overlap is a common source of confusion but also provides flexibility in handling data of different sizes.</p>

<h3 id="memory-addressing">Memory Addressing</h3>

<p>x86 and x86-64 use several addressing modes to access memory:</p>

<ul>
  <li><strong>Immediate</strong>: Direct value (e.g., <code class="language-plaintext highlighter-rouge">mov eax, 42</code>)</li>
  <li><strong>Register</strong>: Value in a register (e.g., <code class="language-plaintext highlighter-rouge">mov eax, ebx</code>)</li>
  <li><strong>Direct</strong>: Value at a specific memory address (e.g., <code class="language-plaintext highlighter-rouge">mov eax, [0x12345678]</code>)</li>
  <li><strong>Register indirect</strong>: Value at the address contained in a register (e.g., <code class="language-plaintext highlighter-rouge">mov eax, [ebx]</code>)</li>
  <li><strong>Base + displacement</strong>: Value at the address calculated as register + offset (e.g., <code class="language-plaintext highlighter-rouge">mov eax, [ebx+20]</code>)</li>
  <li><strong>Scaled index</strong>: Value at the address calculated using multiple components (e.g., <code class="language-plaintext highlighter-rouge">mov eax, [ebx+ecx*4+20]</code>)</li>
</ul>

<p>This flexible addressing system allows efficient access to arrays, structures, and other complex data organizations.</p>

<h3 id="common-instructions">Common Instructions</h3>

<p>Let’s examine some of the most frequently encountered x86/x86-64 instructions in reverse engineering:</p>

<h4 id="data-movement">Data Movement</h4>

<pre><code class="language-assembly">mov dest, src      ; Copy src to dest
push src           ; Push src onto the stack
pop dest           ; Pop value from stack into dest
lea dest, [addr]   ; Load effective address (calculate address without accessing memory)
xchg a, b          ; Exchange values between a and b
</code></pre>

<p><code class="language-plaintext highlighter-rouge">mov</code> is likely the most common instruction you’ll see. It simply copies data from the source to the destination. The source and destination can be registers, memory locations, or immediate values (with restrictions).</p>

<p><code class="language-plaintext highlighter-rouge">lea</code> (Load Effective Address) is particularly interesting as it calculates an address but doesn’t access memory. It’s often used for pointer arithmetic or quick calculations.</p>

<h4 id="arithmetic">Arithmetic</h4>

<pre><code class="language-assembly">add dest, src      ; dest = dest + src
sub dest, src      ; dest = dest - src
inc dest           ; Increment dest by 1
dec dest           ; Decrement dest by 1
mul src            ; Unsigned multiply (EAX * src)
imul src           ; Signed multiply
div src            ; Unsigned divide (EDX:EAX / src)
idiv src           ; Signed divide
neg dest           ; Negate (two's complement)
</code></pre>

<p>Arithmetic instructions typically modify the flags register based on their result, which can then be used by conditional jumps.</p>

<h4 id="logical-operations">Logical Operations</h4>

<pre><code class="language-assembly">and dest, src      ; Bitwise AND
or dest, src       ; Bitwise OR
xor dest, src      ; Bitwise XOR
not dest           ; Bitwise NOT
shl dest, count    ; Shift left
shr dest, count    ; Shift right (unsigned)
sar dest, count    ; Shift right (signed)
rol dest, count    ; Rotate left
ror dest, count    ; Rotate right
</code></pre>

<p><code class="language-plaintext highlighter-rouge">xor reg, reg</code> (e.g., <code class="language-plaintext highlighter-rouge">xor eax, eax</code>) is commonly used to zero a register, as it’s more compact than <code class="language-plaintext highlighter-rouge">mov reg, 0</code>.</p>

<h4 id="comparison-and-testing">Comparison and Testing</h4>

<pre><code class="language-assembly">cmp a, b           ; Compare a and b (compute a - b and set flags)
test a, b          ; Bitwise AND for testing (compute a &amp; b and set flags)
</code></pre>

<p>These instructions don’t store their result; they only set flags that can be used by subsequent conditional jumps.</p>

<h4 id="control-flow">Control Flow</h4>

<pre><code class="language-assembly">jmp target         ; Unconditional jump
je/jz target       ; Jump if equal/zero
jne/jnz target     ; Jump if not equal/not zero
jg/jnle target     ; Jump if greater (signed)
ja/jnbe target     ; Jump if above (unsigned)
jl/jnge target     ; Jump if less (signed)
jb/jnae target     ; Jump if below (unsigned)
call target        ; Call subroutine
ret                ; Return from subroutine
</code></pre>

<p>Conditional jumps test the flags set by previous instructions (often <code class="language-plaintext highlighter-rouge">cmp</code> or <code class="language-plaintext highlighter-rouge">test</code>). The signed/unsigned distinction is important when comparing values that could be interpreted as either signed or unsigned integers.</p>

<h3 id="calling-conventions">Calling Conventions</h3>

<p>Calling conventions define how functions receive parameters and return values. They’re crucial for understanding function interactions in disassembled code.</p>

<h4 id="32-bit-calling-conventions">32-bit Calling Conventions</h4>

<p>Common 32-bit x86 calling conventions include:</p>

<ul>
  <li><strong>cdecl</strong>: Parameters pushed right-to-left, caller cleans the stack, return value in EAX</li>
  <li><strong>stdcall</strong>: Parameters pushed right-to-left, callee cleans the stack, return value in EAX</li>
  <li><strong>fastcall</strong>: First two parameters in ECX and EDX, others pushed right-to-left, callee cleans the stack</li>
</ul>

<p>A typical cdecl function call might look like:</p>

<pre><code class="language-assembly">; Calling func(1, 2, 3)
push 3          ; Push parameters right-to-left
push 2
push 1
call func       ; Call the function
add esp, 12     ; Clean up stack (3 parameters * 4 bytes)
</code></pre>

<h4 id="64-bit-calling-conventions">64-bit Calling Conventions</h4>

<p>The x86-64 architecture primarily uses:</p>

<ul>
  <li><strong>Microsoft x64</strong>: First four parameters in RCX, RDX, R8, R9; others pushed on stack; 32 bytes of “shadow space” reserved on stack</li>
  <li><strong>System V AMD64 ABI</strong> (Linux, macOS): First six parameters in RDI, RSI, RDX, RCX, R8, R9; others pushed on stack</li>
</ul>

<p>Both conventions return values in RAX and preserve certain registers across calls.</p>

<p>A System V AMD64 function call might look like:</p>

<pre><code class="language-assembly">; Calling func(1, 2, 3, 4, 5, 6, 7)
mov rdi, 1      ; First six parameters in registers
mov rsi, 2
mov rdx, 3
mov rcx, 4
mov r8, 5
mov r9, 6
push 7          ; Seventh parameter on stack
call func
add rsp, 8      ; Clean up stack
</code></pre>

<h3 id="stack-frame-management">Stack Frame Management</h3>

<p>Functions typically establish a stack frame for local variables and saved registers. The standard prologue and epilogue patterns are important to recognize:</p>

<h4 id="32-bit-stack-frame">32-bit Stack Frame</h4>

<pre><code class="language-assembly">; Function prologue
push ebp         ; Save old base pointer
mov ebp, esp     ; Set new base pointer
sub esp, X       ; Allocate X bytes for local variables

; Function body
; Local variables accessed as [ebp-X]
; Parameters accessed as [ebp+X]

; Function epilogue
mov esp, ebp     ; Restore stack pointer
pop ebp          ; Restore base pointer
ret              ; Return to caller
</code></pre>

<h4 id="64-bit-stack-frame">64-bit Stack Frame</h4>

<p>64-bit code often uses a more streamlined approach, especially for leaf functions (those that don’t call other functions):</p>

<pre><code class="language-assembly">; Minimal function prologue
push rbp         ; Save base pointer (optional)
sub rsp, X       ; Allocate stack space (typically aligned to 16 bytes)

; Function body

; Minimal function epilogue
add rsp, X       ; Free stack space
pop rbp          ; Restore base pointer (if pushed)
ret              ; Return to caller
</code></pre>

<p>More complex functions may save additional registers or use frame pointers similarly to 32-bit code.</p>

<h2 id="arm-architecture">ARM Architecture</h2>

<p>The ARM architecture is dominant in mobile devices and increasingly important in other domains. Its instruction set differs significantly from x86, making it important to understand for comprehensive reverse engineering capabilities.</p>

<h3 id="register-set-1">Register Set</h3>

<p>ARM processors use a load-store architecture, where operations are performed on registers, with separate instructions to load from or store to memory.</p>

<h4 id="32-bit-arm-registers">32-bit ARM Registers</h4>

<p>The 32-bit ARM architecture provides 16 general-purpose registers:</p>

<ul>
  <li><strong>R0-R3</strong>: Function arguments and return values</li>
  <li><strong>R4-R11</strong>: Local variables (preserved across function calls)</li>
  <li><strong>R12</strong>: Intra-procedure call scratch register (IP)</li>
  <li><strong>R13</strong>: Stack pointer (SP)</li>
  <li><strong>R14</strong>: Link register (LR), holds return address</li>
  <li><strong>R15</strong>: Program counter (PC)</li>
</ul>

<p>Additionally, the Current Program Status Register (CPSR) contains condition flags and processor state information.</p>

<h4 id="64-bit-arm64aarch64-registers">64-bit ARM64/AArch64 Registers</h4>

<p>The 64-bit ARM architecture expands to 31 general-purpose registers:</p>

<ul>
  <li><strong>X0-X7</strong>: Function arguments and return values</li>
  <li><strong>X8</strong>: Indirect result location register</li>
  <li><strong>X9-X15</strong>: Temporary registers</li>
  <li><strong>X16-X17</strong>: Intra-procedure call registers</li>
  <li><strong>X18</strong>: Platform register (reserved in some ABIs)</li>
  <li><strong>X19-X28</strong>: Callee-saved registers</li>
  <li><strong>X29</strong>: Frame pointer (FP)</li>
  <li><strong>X30</strong>: Link register (LR)</li>
  <li><strong>SP</strong>: Stack pointer (not numbered)</li>
</ul>

<p>The lower 32 bits of each X register can be accessed as W0-W30.</p>

<h3 id="instruction-sets">Instruction Sets</h3>

<p>ARM supports multiple instruction sets:</p>

<ul>
  <li><strong>ARM</strong>: 32-bit fixed-length instructions</li>
  <li><strong>Thumb</strong>: 16-bit compressed instructions for better code density</li>
  <li><strong>Thumb-2</strong>: Extension of Thumb with both 16-bit and 32-bit instructions</li>
  <li><strong>A64</strong>: 64-bit instructions for AArch64</li>
</ul>

<p>When reverse engineering ARM binaries, you may encounter any of these instruction sets, sometimes mixed within the same program.</p>

<h3 id="common-instructions-1">Common Instructions</h3>

<p>Let’s examine some common ARM instructions you’ll encounter in reverse engineering:</p>

<h4 id="data-movement-1">Data Movement</h4>

<pre><code class="language-assembly">MOV Rd, Operand    ; Move value to register
LDR Rd, [Rn, #off] ; Load from memory
STR Rd, [Rn, #off] ; Store to memory
PUSH {reg list}    ; Push registers onto stack
POP {reg list}     ; Pop registers from stack
</code></pre>

<p>ARM’s load-store architecture means that operations can only be performed on registers, not directly on memory.</p>

<h4 id="arithmetic-1">Arithmetic</h4>

<pre><code class="language-assembly">ADD Rd, Rn, Operand ; Rd = Rn + Operand
SUB Rd, Rn, Operand ; Rd = Rn - Operand
MUL Rd, Rn, Rm      ; Rd = Rn * Rm
DIV Rd, Rn, Rm      ; Rd = Rn / Rm
</code></pre>

<p>Many ARM instructions can optionally update the condition flags by adding an ‘S’ suffix (e.g., <code class="language-plaintext highlighter-rouge">ADDS</code>, <code class="language-plaintext highlighter-rouge">SUBS</code>).</p>

<h4 id="logical-operations-1">Logical Operations</h4>

<pre><code class="language-assembly">AND Rd, Rn, Operand ; Bitwise AND
ORR Rd, Rn, Operand ; Bitwise OR
EOR Rd, Rn, Operand ; Bitwise XOR (exclusive OR)
BIC Rd, Rn, Operand ; Bit clear (AND with complement)
LSL Rd, Rn, #shift  ; Logical shift left
LSR Rd, Rn, #shift  ; Logical shift right
</code></pre>

<h4 id="comparison">Comparison</h4>

<pre><code class="language-assembly">CMP Rn, Operand     ; Compare (set flags based on Rn - Operand)
TST Rn, Operand     ; Test bits (set flags based on Rn &amp; Operand)
</code></pre>

<h4 id="control-flow-1">Control Flow</h4>

<pre><code class="language-assembly">B label             ; Branch (jump)
BL label            ; Branch with link (call subroutine)
BX Rn               ; Branch and exchange (can switch instruction sets)
BLX Rn              ; Branch with link and exchange
BEQ label           ; Branch if equal
BNE label           ; Branch if not equal
BGT label           ; Branch if greater than
BLT label           ; Branch if less than
</code></pre>

<p>Conditional execution is a distinctive feature of ARM. Many instructions can be conditionally executed based on the flags, using suffixes like EQ (equal), NE (not equal), GT (greater than), etc.</p>

<h3 id="arm-calling-conventions">ARM Calling Conventions</h3>

<p>ARM uses register-based parameter passing:</p>

<h4 id="32-bit-arm">32-bit ARM</h4>

<ul>
  <li>First four parameters in R0-R3</li>
  <li>Additional parameters on stack</li>
  <li>Return value in R0 (or R0:R1 for 64-bit values)</li>
  <li>Callee must preserve R4-R11 and SP</li>
</ul>

<h4 id="64-bit-arm-aarch64">64-bit ARM (AArch64)</h4>

<ul>
  <li>First eight parameters in X0-X7</li>
  <li>Additional parameters on stack</li>
  <li>Return value in X0 (or X0:X1 for 128-bit values)</li>
  <li>Callee must preserve X19-X28, FP, and SP</li>
</ul>

<h3 id="arm-function-prologues-and-epilogues">ARM Function Prologues and Epilogues</h3>

<p>ARM functions typically save registers and establish a frame using patterns like:</p>

<h4 id="32-bit-arm-1">32-bit ARM</h4>

<pre><code class="language-assembly">; Prologue
PUSH {R4-R11, LR}   ; Save registers and return address
SUB SP, SP, #X      ; Allocate local variables

; Function body

; Epilogue
ADD SP, SP, #X      ; Deallocate local variables
POP {R4-R11, PC}    ; Restore registers and return (PC = popped LR)
</code></pre>

<h4 id="64-bit-arm-aarch64-1">64-bit ARM (AArch64)</h4>

<pre><code class="language-assembly">; Prologue
STP X29, X30, [SP, #-16]!  ; Save FP and LR, update SP
MOV X29, SP                ; Set frame pointer
STP X19, X20, [SP, #-16]!  ; Save preserved registers

; Function body

; Epilogue
LDP X19, X20, [SP], #16    ; Restore preserved registers
LDP X29, X30, [SP], #16    ; Restore FP and LR
RET                        ; Return (using LR)
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">STP</code> (Store Pair) and <code class="language-plaintext highlighter-rouge">LDP</code> (Load Pair) instructions are commonly used in AArch64 for efficient register saving and restoring.</p>

<h2 id="mips-architecture">MIPS Architecture</h2>

<p>While less common than x86 or ARM, the MIPS architecture is important in embedded systems, networking equipment, and some gaming consoles. Its clean, RISC-based design makes it an interesting study in assembly language principles.</p>

<h3 id="register-set-2">Register Set</h3>

<p>MIPS provides 32 general-purpose registers, conventionally used as follows:</p>

<ul>
  <li><strong>$0</strong>: Always contains zero</li>
  <li><strong>$1</strong> ($at): Assembler temporary</li>
  <li><strong>$2-$3</strong> ($v0-$v1): Function return values</li>
  <li><strong>$4-$7</strong> ($a0-$a3): Function arguments</li>
  <li><strong>$8-$15</strong> ($t0-$t7): Temporary registers</li>
  <li><strong>$16-$23</strong> ($s0-$s7): Saved registers (preserved across calls)</li>
  <li><strong>$24-$25</strong> ($t8-$t9): More temporary registers</li>
  <li><strong>$26-$27</strong> ($k0-$k1): Reserved for kernel use</li>
  <li><strong>$28</strong> ($gp): Global pointer</li>
  <li><strong>$29</strong> ($sp): Stack pointer</li>
  <li><strong>$30</strong> ($fp): Frame pointer</li>
  <li><strong>$31</strong> ($ra): Return address</li>
</ul>

<p>Additionally, MIPS has a program counter (PC) and a status register containing condition flags.</p>

<h3 id="common-instructions-2">Common Instructions</h3>

<p>MIPS instructions follow a consistent format, typically with three operands.</p>

<h4 id="data-movement-2">Data Movement</h4>

<pre><code class="language-assembly">move $t0, $t1      ; Copy value (pseudoinstruction for addu $t0, $t1, $zero)
lw $t0, offset($t1) ; Load word from memory
sw $t0, offset($t1) ; Store word to memory
li $t0, imm        ; Load immediate value (pseudoinstruction)
</code></pre>

<h4 id="arithmetic-2">Arithmetic</h4>

<pre><code class="language-assembly">addu $t0, $t1, $t2 ; $t0 = $t1 + $t2 (unsigned)
subu $t0, $t1, $t2 ; $t0 = $t1 - $t2 (unsigned)
mul $t0, $t1, $t2  ; $t0 = $t1 * $t2
div $t0, $t1       ; Lo = $t0 / $t1, Hi = $t0 % $t1
mflo $t0           ; Move from Lo register
mfhi $t0           ; Move from Hi register
</code></pre>

<p>MIPS distinguishes between operations that can cause exceptions (e.g., <code class="language-plaintext highlighter-rouge">add</code>, which can overflow) and those that don’t (e.g., <code class="language-plaintext highlighter-rouge">addu</code>, which ignores overflow).</p>

<h4 id="logical-operations-2">Logical Operations</h4>

<pre><code class="language-assembly">and $t0, $t1, $t2  ; Bitwise AND
or $t0, $t1, $t2   ; Bitwise OR
xor $t0, $t1, $t2  ; Bitwise XOR
nor $t0, $t1, $t2  ; Bitwise NOR
sll $t0, $t1, 5    ; Shift left logical
srl $t0, $t1, 5    ; Shift right logical
</code></pre>

<h4 id="comparison-and-branching">Comparison and Branching</h4>

<pre><code class="language-assembly">beq $t0, $t1, label ; Branch if equal
bne $t0, $t1, label ; Branch if not equal
slt $t0, $t1, $t2   ; Set if less than ($t0 = 1 if $t1 &lt; $t2, else 0)
slti $t0, $t1, imm  ; Set if less than immediate
blez $t0, label     ; Branch if less than or equal to zero
bgtz $t0, label     ; Branch if greater than zero
</code></pre>

<p>MIPS doesn’t have a dedicated compare instruction; instead, it uses <code class="language-plaintext highlighter-rouge">slt</code> and similar instructions to set a register based on a comparison, which can then be tested with a branch.</p>

<h4 id="control-flow-2">Control Flow</h4>

<pre><code class="language-assembly">j label             ; Jump to address
jal label           ; Jump and link (call subroutine)
jr $t0              ; Jump register (often used for returns with $ra)
jalr $t0            ; Jump and link register
</code></pre>

<h3 id="mips-calling-convention">MIPS Calling Convention</h3>

<p>The standard MIPS calling convention uses:</p>

<ul>
  <li>First four arguments in $a0-$a3</li>
  <li>Additional arguments on stack</li>
  <li>Return values in $v0-$v1</li>
  <li>Callee must preserve $s0-$s7, $fp, $gp, $sp, and $ra</li>
</ul>

<h3 id="mips-function-prologues-and-epilogues">MIPS Function Prologues and Epilogues</h3>

<p>MIPS functions typically follow this pattern:</p>

<pre><code class="language-assembly">; Prologue
addiu $sp, $sp, -X    ; Allocate stack frame
sw $ra, (X-4)($sp)    ; Save return address
sw $fp, (X-8)($sp)    ; Save frame pointer
sw $s0, (X-12)($sp)   ; Save preserved registers
...
move $fp, $sp         ; Set frame pointer

; Function body

; Epilogue
move $sp, $fp         ; Restore stack pointer
lw $s0, (X-12)($sp)   ; Restore preserved registers
...
lw $fp, (X-8)($sp)    ; Restore frame pointer
lw $ra, (X-4)($sp)    ; Restore return address
addiu $sp, $sp, X     ; Deallocate stack frame
jr $ra                ; Return
</code></pre>

<p>The delay slot is a MIPS peculiarity: the instruction immediately following a branch or jump is executed before the branch takes effect. This can make disassembly more confusing for beginners.</p>

<h2 id="common-assembly-patterns">Common Assembly Patterns</h2>

<p>Regardless of the specific architecture, certain code patterns appear frequently in disassembled code. Recognizing these patterns can significantly speed up your analysis.</p>

<h3 id="function-calls-and-returns">Function Calls and Returns</h3>

<p>Function calls involve saving the return address and transferring control to the target function. Returns restore the previous execution context.</p>

<h4 id="x86x86-64">x86/x86-64</h4>

<pre><code class="language-assembly">; Call
call function_name

; Return
ret
</code></pre>

<h4 id="arm">ARM</h4>

<pre><code class="language-assembly">; Call
BL function_name

; Return
BX LR      ; 32-bit ARM
RET        ; 64-bit ARM
</code></pre>

<h4 id="mips">MIPS</h4>

<pre><code class="language-assembly">; Call
jal function_name

; Return
jr $ra
</code></pre>

<h3 id="loops">Loops</h3>

<p>Loops typically involve initializing a counter, comparing it to a limit, and branching conditionally.</p>

<h4 id="x86x86-64-counting-loop">x86/x86-64 Counting Loop</h4>

<pre><code class="language-assembly">    mov ecx, 10     ; Initialize counter
loop_start:
    ; Loop body
    dec ecx         ; Decrement counter
    jnz loop_start  ; Jump if not zero
</code></pre>

<h4 id="arm-counting-loop">ARM Counting Loop</h4>

<pre><code class="language-assembly">    MOV R0, #10     ; Initialize counter
loop_start:
    ; Loop body
    SUBS R0, R0, #1 ; Decrement counter and update flags
    BNE loop_start  ; Branch if not equal to zero
</code></pre>

<h4 id="mips-counting-loop">MIPS Counting Loop</h4>

<pre><code class="language-assembly">    li $t0, 10      ; Initialize counter
loop_start:
    ; Loop body
    addiu $t0, $t0, -1 ; Decrement counter
    bnez $t0, loop_start ; Branch if not equal to zero
</code></pre>

<h3 id="conditional-statements">Conditional Statements</h3>

<p>Conditional statements (if-then-else) involve comparing values and branching based on the result.</p>

<h4 id="x86x86-64-if-then-else">x86/x86-64 If-Then-Else</h4>

<pre><code class="language-assembly">    cmp eax, ebx    ; Compare values
    jge else_branch ; Jump if greater or equal
    ; Then branch code
    jmp end_if
else_branch:
    ; Else branch code
end_if:
</code></pre>

<h4 id="arm-if-then-else">ARM If-Then-Else</h4>

<pre><code class="language-assembly">    CMP R0, R1      ; Compare values
    BGE else_branch ; Branch if greater or equal
    ; Then branch code
    B end_if
else_branch:
    ; Else branch code
end_if:
</code></pre>

<h4 id="mips-if-then-else">MIPS If-Then-Else</h4>

<pre><code class="language-assembly">    slt $t0, $a0, $a1 ; Set $t0 to 1 if $a0 &lt; $a1
    beqz $t0, else_branch ; Branch if $t0 equals zero
    ; Then branch code
    j end_if
else_branch:
    ; Else branch code
end_if:
</code></pre>

<h3 id="switch-statements">Switch Statements</h3>

<p>Switch statements can be implemented in various ways, but often use jump tables for efficiency.</p>

<h4 id="x86x86-64-jump-table">x86/x86-64 Jump Table</h4>

<pre><code class="language-assembly">    cmp eax, 5      ; Check if index is in range
    ja default_case ; Jump if above 5
    jmp [jump_table + eax*4] ; Jump to appropriate case

jump_table:
    dd case_0
    dd case_1
    dd case_2
    dd case_3
    dd case_4
    dd case_5

case_0:
    ; Case 0 code
    jmp end_switch
case_1:
    ; Case 1 code
    jmp end_switch
; ...
default_case:
    ; Default case code
end_switch:
</code></pre>

<h3 id="string-operations">String Operations</h3>

<p>String processing often involves loops that operate on one character at a time.</p>

<h4 id="x86x86-64-string-length">x86/x86-64 String Length</h4>

<pre><code class="language-assembly">    mov ecx, 0      ; Initialize counter
    mov esi, string_ptr ; Point to string
loop_start:
    mov al, [esi]   ; Load character
    test al, al     ; Check if null terminator
    jz done         ; Jump if zero
    inc ecx         ; Increment counter
    inc esi         ; Move to next character
    jmp loop_start
done:
    ; ECX now contains the string length
</code></pre>

<h3 id="memory-allocation">Memory Allocation</h3>

<p>Dynamic memory allocation typically involves calling system functions like malloc/HeapAlloc.</p>

<h4 id="x86x86-64-heap-allocation">x86/x86-64 Heap Allocation</h4>

<pre><code class="language-assembly">    push 100        ; Size to allocate (32-bit)
    call malloc
    add esp, 4      ; Clean up stack
    ; EAX now contains the allocated pointer

    ; Or in 64-bit code:
    mov rcx, 100    ; Size to allocate
    call malloc
    ; RAX now contains the allocated pointer
</code></pre>

<h2 id="reading-disassembled-code">Reading Disassembled Code</h2>

<p>Now that we’ve covered the basics of assembly language across different architectures, let’s discuss strategies for effectively reading and analyzing disassembled code.</p>

<h3 id="identifying-function-boundaries">Identifying Function Boundaries</h3>

<p>The first step in analyzing disassembled code is identifying where functions begin and end. Look for:</p>

<ul>
  <li>Function prologues (stack setup, register saving)</li>
  <li>Function epilogues (register restoration, return instructions)</li>
  <li>References from call instructions</li>
</ul>

<p>Modern disassemblers like IDA Pro and Ghidra automatically identify functions, but understanding the patterns helps when automatic analysis is incomplete.</p>

<h3 id="recognizing-local-variables-and-parameters">Recognizing Local Variables and Parameters</h3>

<p>Local variables and parameters are typically accessed relative to the stack or frame pointer:</p>

<ul>
  <li>In x86, parameters are often at positive offsets from EBP (<code class="language-plaintext highlighter-rouge">[ebp+8]</code>, <code class="language-plaintext highlighter-rouge">[ebp+12]</code>, etc.), while local variables are at negative offsets (<code class="language-plaintext highlighter-rouge">[ebp-4]</code>, <code class="language-plaintext highlighter-rouge">[ebp-8]</code>, etc.)</li>
  <li>In x86-64, the first few parameters may be in registers, with additional parameters on the stack</li>
  <li>In ARM, parameters start in registers (R0-R3 or X0-X7), with additional parameters on the stack</li>
</ul>

<p>Tracking these accesses helps understand the function’s data flow.</p>

<h3 id="following-control-flow">Following Control Flow</h3>

<p>Control flow analysis involves tracking how execution moves through the code:</p>

<ol>
  <li>Start at the function entry point</li>
  <li>Follow sequential execution until a branch or jump</li>
  <li>For conditional branches, analyze both paths</li>
  <li>For function calls, note the call target and continue after the call</li>
  <li>For returns, identify where execution might resume (call sites)</li>
</ol>

<p>Drawing a control flow graph (manually or using tools) can help visualize complex functions.</p>

<h3 id="understanding-data-transformations">Understanding Data Transformations</h3>

<p>To understand what a function does, focus on how it transforms data:</p>

<ol>
  <li>Identify input sources (parameters, global variables, memory reads)</li>
  <li>Track how these inputs are processed through calculations and operations</li>
  <li>Identify output destinations (return values, memory writes, global variables)</li>
</ol>

<p>Pay special attention to patterns that suggest specific algorithms or operations (encryption, hashing, compression, etc.).</p>

<h3 id="dealing-with-compiler-optimizations">Dealing with Compiler Optimizations</h3>

<p>Compiler optimizations can make disassembly more challenging to read:</p>

<ul>
  <li><strong>Inlining</strong>: Functions inserted directly at call sites rather than called</li>
  <li><strong>Register allocation</strong>: Variables kept in registers rather than on the stack</li>
  <li><strong>Loop unrolling</strong>: Loops expanded to reduce iteration overhead</li>
  <li><strong>Instruction reordering</strong>: Instructions rearranged for better pipeline efficiency</li>
  <li><strong>SIMD instructions</strong>: Vector operations that process multiple data elements simultaneously</li>
</ul>

<p>When facing heavily optimized code, focus on the overall data flow rather than trying to match each instruction to source code constructs.</p>

<h3 id="annotating-disassembly">Annotating Disassembly</h3>

<p>As you analyze disassembled code, maintain annotations to track your understanding:</p>

<ul>
  <li>Rename functions based on their purpose</li>
  <li>Rename registers or memory locations based on their usage</li>
  <li>Add comments explaining complex operations</li>
  <li>Document identified algorithms or patterns</li>
</ul>

<p>These annotations transform raw disassembly into a more readable form that captures your analysis insights.</p>

<h2 id="architecture-specific-challenges">Architecture-Specific Challenges</h2>

<p>Each architecture presents unique challenges for reverse engineers.</p>

<h3 id="x86x86-64-challenges">x86/x86-64 Challenges</h3>

<ul>
  <li><strong>Complex instruction set</strong>: The x86 family has hundreds of instructions with various forms and options</li>
  <li><strong>Variable instruction length</strong>: Instructions can be 1-15 bytes, making it possible to interpret the same bytes differently depending on alignment</li>
  <li><strong>Implicit operations</strong>: Some instructions have side effects not explicitly stated in the mnemonic</li>
  <li><strong>Multiple calling conventions</strong>: Different conventions may be used in the same program</li>
</ul>

<h3 id="arm-challenges">ARM Challenges</h3>

<ul>
  <li><strong>Instruction set switching</strong>: Code can switch between ARM and Thumb modes</li>
  <li><strong>Conditional execution</strong>: Many instructions can be conditionally executed based on flags</li>
  <li><strong>PC-relative addressing</strong>: Code often uses PC-relative addressing for position-independent execution</li>
  <li><strong>Thumb-2 mixed-width instructions</strong>: Thumb-2 mixes 16-bit and 32-bit instructions</li>
</ul>

<h3 id="mips-challenges">MIPS Challenges</h3>

<ul>
  <li><strong>Delay slots</strong>: The instruction after a branch is executed before the branch takes effect</li>
  <li><strong>Branch likely instructions</strong>: Conditional branches that nullify the delay slot if not taken</li>
  <li><strong>Load delay slots</strong>: In some MIPS implementations, the result of a load isn’t available in the immediately following instruction</li>
  <li><strong>Hi/Lo registers</strong>: Division and multiplication use special registers for results</li>
</ul>

<h2 id="practical-analysis-strategies">Practical Analysis Strategies</h2>

<p>Let’s explore practical strategies for analyzing assembly code across different scenarios.</p>

<h3 id="bottom-up-analysis">Bottom-Up Analysis</h3>

<p>Bottom-up analysis starts with individual instructions and builds toward higher-level understanding:</p>

<ol>
  <li>Identify basic blocks (straight-line code sequences)</li>
  <li>Determine the purpose of each basic block</li>
  <li>Analyze how blocks connect to form larger structures</li>
  <li>Gradually build a functional understanding</li>
</ol>

<p>This approach works well for smaller functions or when you need detailed understanding of specific code sections.</p>

<h3 id="top-down-analysis">Top-Down Analysis</h3>

<p>Top-down analysis starts with program structure and refines understanding progressively:</p>

<ol>
  <li>Identify major functions and their relationships</li>
  <li>Determine the general purpose of each function based on its calls and data access</li>
  <li>Focus on functions of interest and analyze their internal logic</li>
  <li>Drill down to instruction-level details only when necessary</li>
</ol>

<p>This approach is efficient for larger programs where complete analysis of every function isn’t feasible.</p>

<h3 id="signature-based-analysis">Signature-Based Analysis</h3>

<p>Signature-based analysis uses known patterns to identify familiar code:</p>

<ol>
  <li>Recognize common compiler-generated patterns</li>
  <li>Identify standard library functions</li>
  <li>Detect known algorithms (cryptographic functions, compression routines, etc.)</li>
  <li>Use these identified elements as anchors for further analysis</li>
</ol>

<p>This approach leverages prior knowledge to accelerate analysis.</p>

<h3 id="dynamic-assisted-analysis">Dynamic-Assisted Analysis</h3>

<p>Combining static disassembly with dynamic execution information:</p>

<ol>
  <li>Run the program in a debugger</li>
  <li>Observe actual values in registers and memory</li>
  <li>Use this runtime information to inform static analysis</li>
  <li>Iterate between static and dynamic analysis</li>
</ol>

<p>This approach is particularly effective for complex code or when static analysis alone is insufficient.</p>

<h2 id="case-study-cross-architecture-analysis">Case Study: Cross-Architecture Analysis</h2>

<p>Let’s examine a simple function implemented across different architectures to highlight similarities and differences in assembly patterns.</p>

<p>Consider this C function that calculates the factorial of a number:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="x86-64-implementation">x86-64 Implementation</h3>

<pre><code class="language-assembly">factorial:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     [rbp-4], edi    ; Store parameter n
    cmp     dword [rbp-4], 1
    jg      .else_branch
    mov     eax, 1          ; Return 1
    jmp     .end
.else_branch:
    mov     eax, [rbp-4]    ; Load n
    sub     eax, 1          ; Calculate n-1
    mov     edi, eax        ; Set parameter for recursive call
    call    factorial
    mov     edx, [rbp-4]    ; Load n again
    imul    eax, edx        ; Multiply result by n
.end:
    leave
    ret
</code></pre>

<h3 id="arm64-implementation">ARM64 Implementation</h3>

<pre><code class="language-assembly">factorial:
    stp     x29, x30, [sp, #-16]!  ; Save FP and LR
    mov     x29, sp                ; Set frame pointer
    cmp     w0, #1                 ; Compare n with 1
    ble     .base_case             ; Branch if n &lt;= 1
    str     w0, [sp, #12]          ; Store n on stack
    sub     w0, w0, #1             ; Calculate n-1
    bl      factorial              ; Recursive call
    ldr     w1, [sp, #12]          ; Load n from stack
    mul     w0, w0, w1             ; Multiply result by n
    b       .end
.base_case:
    mov     w0, #1                 ; Return 1
.end:
    ldp     x29, x30, [sp], #16    ; Restore FP and LR
    ret
</code></pre>

<h3 id="mips-implementation">MIPS Implementation</h3>

<pre><code class="language-assembly">factorial:
    addiu   $sp, $sp, -8           ; Allocate stack frame
    sw      $ra, 4($sp)            ; Save return address
    sw      $a0, 0($sp)            ; Save parameter n
    ble     $a0, 1, base_case      ; Branch if n &lt;= 1
    addiu   $a0, $a0, -1           ; Calculate n-1
    jal     factorial              ; Recursive call
    lw      $a0, 0($sp)            ; Restore n
    mul     $v0, $a0, $v0          ; Multiply n by factorial(n-1)
    j       end
base_case:
    li      $v0, 1                 ; Return 1
end:
    lw      $ra, 4($sp)            ; Restore return address
    addiu   $sp, $sp, 8            ; Deallocate stack frame
    jr      $ra                    ; Return
</code></pre>

<h3 id="analysis-comparison">Analysis Comparison</h3>

<p>Despite the different instruction sets, we can identify common patterns:</p>

<ol>
  <li><strong>Function setup</strong>: Each version saves necessary registers and allocates stack space</li>
  <li><strong>Conditional check</strong>: Each tests if n &lt;= 1 and branches accordingly</li>
  <li><strong>Base case</strong>: Each returns 1 for the base case</li>
  <li><strong>Recursive case</strong>: Each calculates n-1, makes a recursive call, then multiplies the result by n</li>
  <li><strong>Function cleanup</strong>: Each restores saved registers and returns</li>
</ol>

<p>The differences lie in:</p>
<ul>
  <li>Register usage (based on the architecture’s calling convention)</li>
  <li>Instruction syntax and capabilities</li>
  <li>Stack frame organization</li>
</ul>

<p>This cross-architecture perspective helps develop a more abstract understanding of code patterns that transcends specific instruction sets.</p>

<h2 id="summary">Summary</h2>

<p>In this chapter, we’ve explored the fundamentals of assembly language across multiple architectures, focusing on the concepts and patterns most relevant to reverse engineering. We’ve covered:</p>

<ul>
  <li>The basic computational model underlying assembly language</li>
  <li>Key features of x86/x86-64, ARM, and MIPS architectures</li>
  <li>Common instructions and their purposes</li>
  <li>Calling conventions and function structures</li>
  <li>Recurring code patterns for loops, conditionals, and other constructs</li>
  <li>Strategies for reading and analyzing disassembled code</li>
  <li>Architecture-specific challenges and how to address them</li>
</ul>

<p>Mastering assembly language is a journey that requires practice and exposure to diverse code examples. As you gain experience, you’ll develop an intuition for recognizing patterns and understanding code functionality from its assembly representation.</p>

<p>In the next chapter, we’ll build on this foundation to explore static code analysis techniques that help extract meaning from disassembled programs more efficiently.</p>

<h2 id="exercises">Exercises</h2>

<ol>
  <li>
    <p><strong>Register Tracking</strong>: Choose a simple function from a disassembled program and trace how values move between registers and memory. Create a table showing the value of each register at different points in the function’s execution.</p>
  </li>
  <li><strong>Pattern Recognition</strong>: Find examples of the following patterns in disassembled code:
    <ul>
      <li>A loop that iterates a fixed number of times</li>
      <li>A function that processes a null-terminated string</li>
      <li>A switch statement with at least three cases</li>
      <li>A recursive function</li>
    </ul>
  </li>
  <li>
    <p><strong>Cross-Architecture Translation</strong>: Write a simple C function (e.g., calculating the sum of an array), compile it for different architectures, and compare the resulting assembly. Identify the common logical structure despite the different instruction sets.</p>
  </li>
  <li><strong>Calling Convention Analysis</strong>: Examine a function with multiple parameters in disassembled code. Determine which calling convention it uses and how parameters are passed and returned.</li>
</ol>


  </div>

  <nav class="chapter-navigation">
    
    <a href="/inside-the-machine/chapters/chapter-04-understanding-executable-formats/" class="prev">&laquo; </a>
    
    
    <a href="/inside-the-machine/chapters" class="toc">Table of Contents</a>
    
    
    <a href="/inside-the-machine/chapters/chapter-06-static-code-analysis/" class="next"> &raquo;</a>
    
  </nav>
</article>
  </main>

  <footer class="site-footer">
  <div class="container">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Inside the Machine</h2>
        <p>A comprehensive guide to the art of reverse engineering, exploring various techniques and strategies to extract valuable insights from software systems.
</p>
      </div>

      <div class="footer-col">
        <h2 class="footer-heading">Contact</h2>
        <ul class="contact-list">
          <li><a href="mailto:immadmohit@gmail.com">immadmohit@gmail.com</a></li>
          <li><a href="https://github.com/mohitmishra786">GitHub</a></li>
        </ul>
      </div>

      <div class="footer-col">
        <h2 class="footer-heading">Quick Links</h2>
        <ul class="page-list">
          <li><a href="/inside-the-machine/">Home</a></li>
          <li><a href="/inside-the-machine/chapters">Chapters</a></li>
          <li><a href="/inside-the-machine/about">About</a></li>
        </ul>
      </div>
    </div>

    <div class="copyright">
      <p>&copy; 2025 Mohit Mishra. All rights reserved.</p>
    </div>
  </div>
</footer>
  
  <script src="/inside-the-machine/assets/js/theme-toggle.js"></script>
</body>
</html>