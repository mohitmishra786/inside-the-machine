<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 4: Understanding Executable Formats | Inside the Machine</title>
  <link rel="stylesheet" href="/inside-the-machine/assets/css/main.css">
  <link rel="stylesheet" href="/inside-the-machine/assets/css/chapters.css">
  <link rel="stylesheet" href="/inside-the-machine/assets/css/home.css">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Chapter 4: Understanding Executable Formats" />
<meta name="author" content="Mohit Mishra" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Executable formats are the containers that hold program code and data in a structure the operating system can load and execute. They’re the bridge between the source code a developer writes and the binary instructions a computer executes. Understanding these formats is fundamental to reverse engineering because they define how to locate and interpret the program’s components." />
<meta property="og:description" content="Executable formats are the containers that hold program code and data in a structure the operating system can load and execute. They’re the bridge between the source code a developer writes and the binary instructions a computer executes. Understanding these formats is fundamental to reverse engineering because they define how to locate and interpret the program’s components." />
<link rel="canonical" href="https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-04-understanding-executable-formats/" />
<meta property="og:url" content="https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-04-understanding-executable-formats/" />
<meta property="og:site_name" content="Inside the Machine" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-27T19:00:15+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Chapter 4: Understanding Executable Formats" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mohit Mishra"},"dateModified":"2025-04-27T19:00:15+00:00","datePublished":"2025-04-27T19:00:15+00:00","description":"Executable formats are the containers that hold program code and data in a structure the operating system can load and execute. They’re the bridge between the source code a developer writes and the binary instructions a computer executes. Understanding these formats is fundamental to reverse engineering because they define how to locate and interpret the program’s components.","headline":"Chapter 4: Understanding Executable Formats","mainEntityOfPage":{"@type":"WebPage","@id":"https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-04-understanding-executable-formats/"},"url":"https://mohitmishra786.github.io/inside-the-machine/chapters/chapter-04-understanding-executable-formats/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="site-header">
    <div class="container">
      <a href="/inside-the-machine/" class="site-title">Inside the Machine</a>
      <nav class="site-nav">
        <a href="/inside-the-machine/chapters" class="active">Chapters</a>
        <a href="/inside-the-machine/about" >About</a>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
          <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
        </button>
      </nav>
    </div>
  </header>
  
  <main class="container">
    <article class="chapter">
  <header class="chapter-header">
    <h1>Chapter 4: Understanding Executable Formats</h1>
    
    <div class="chapter-part">Part 2: Disassembly and Analysis</div>
    
  </header>

  <div class="chapter-content">
    <p>Executable formats are the containers that hold program code and data in a structure the operating system can load and execute. They’re the bridge between the source code a developer writes and the binary instructions a computer executes. Understanding these formats is fundamental to reverse engineering because they define how to locate and interpret the program’s components.</p>

<p>In this chapter, we’ll explore the major executable formats across different platforms, examining their structures, components, and the information they provide to reverse engineers. We’ll also look at how to extract and analyze this information using practical tools and techniques.</p>

<h2 id="the-anatomy-of-executable-files">The Anatomy of Executable Files</h2>

<p>Before diving into specific formats, let’s understand the common elements that most executable files share, regardless of platform:</p>

<h3 id="headers">Headers</h3>

<p>Headers contain metadata about the executable, including:</p>
<ul>
  <li>File type and format version</li>
  <li>Target architecture</li>
  <li>Entry point (where execution begins)</li>
  <li>Size and location of various sections</li>
  <li>Required permissions</li>
</ul>

<p>Headers act as a map to the file’s contents, telling the operating system how to interpret and load the executable.</p>

<h3 id="code-sections">Code Sections</h3>

<p>Code sections (often called text sections) contain the executable instructions that the CPU will execute. These sections typically have read and execute permissions but are not writable during normal execution to prevent code modification attacks.</p>

<h3 id="data-sections">Data Sections</h3>

<p>Data sections store the program’s static data, including:</p>
<ul>
  <li>Initialized variables (data with predefined values)</li>
  <li>Uninitialized variables (BSS - Block Started by Symbol)</li>
  <li>Constants and literals</li>
  <li>String tables</li>
</ul>

<p>These sections usually have read and write permissions but are not executable.</p>

<h3 id="import-and-export-tables">Import and Export Tables</h3>

<p>Modern programs rarely operate in isolation. They interact with the operating system and other libraries through:</p>

<ul>
  <li><strong>Import tables</strong>: Lists of functions and data the program needs from external libraries</li>
  <li><strong>Export tables</strong>: Functions and data the program provides for other programs to use</li>
</ul>

<p>These tables are crucial for understanding a program’s external dependencies and functionality.</p>

<h3 id="resources">Resources</h3>

<p>Many executables contain resources such as:</p>
<ul>
  <li>Icons and images</li>
  <li>Dialog layouts</li>
  <li>Menus and UI elements</li>
  <li>Version information</li>
  <li>Embedded files</li>
</ul>

<p>Resources provide valuable context about the program’s functionality and can contain important clues for reverse engineering.</p>

<h3 id="relocation-information">Relocation Information</h3>

<p>Relocation data helps the loader adjust memory addresses when the program can’t be loaded at its preferred base address. This information is particularly important for shared libraries that must work at different memory locations.</p>

<h3 id="debug-information">Debug Information</h3>

<p>Some executables contain debug information that maps machine code back to source code, including:</p>
<ul>
  <li>Function names and parameters</li>
  <li>Variable names and types</li>
  <li>Source file names and line numbers</li>
</ul>

<p>While often stripped from production builds, when present, debug information is invaluable for reverse engineering.</p>

<h2 id="portable-executable-pe-format">Portable Executable (PE) Format</h2>

<p>The Portable Executable format is the standard executable format for Windows operating systems. It evolved from the earlier Common Object File Format (COFF) and is used for EXE, DLL, SYS, and other executable file types in Windows.</p>

<h3 id="pe-file-structure">PE File Structure</h3>

<p>A PE file consists of several components arranged in a specific order:</p>

<ol>
  <li>
    <p><strong>DOS Header and Stub</strong>: A legacy component that displays “This program cannot be run in DOS mode” when the executable is run in MS-DOS.</p>
  </li>
  <li>
    <p><strong>PE Header</strong>: Contains a signature (“PE\0\0”) and the COFF File Header with basic information about the file.</p>
  </li>
  <li><strong>Optional Header</strong>: Despite its name, this header is required for executable files and contains crucial information like:
    <ul>
      <li>Entry point address</li>
      <li>Preferred base address</li>
      <li>Section alignment</li>
      <li>Required operating system version</li>
      <li>Subsystem (GUI, console, etc.)</li>
    </ul>
  </li>
  <li>
    <p><strong>Section Table</strong>: An array of section headers that describe each section’s name, size, location, and characteristics.</p>
  </li>
  <li><strong>Sections</strong>: The actual content of the file, organized according to the section table.</li>
</ol>

<p>Here’s a simplified visualization of a PE file structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────┐
│     DOS Header      │
├─────────────────────┤
│      DOS Stub       │
├─────────────────────┤
│ PE Signature (PE\0\0)│
├─────────────────────┤
│    COFF Header      │
├─────────────────────┤
│   Optional Header   │
├─────────────────────┤
│    Section Table    │
├─────────────────────┤
│    .text section    │ (Code)
├─────────────────────┤
│    .data section    │ (Initialized data)
├─────────────────────┤
│    .rdata section   │ (Read-only data)
├─────────────────────┤
│    .bss section     │ (Uninitialized data)
├─────────────────────┤
│   .rsrc section     │ (Resources)
├─────────────────────┤
│   Other sections    │
└─────────────────────┘
</code></pre></div></div>

<h3 id="common-pe-sections">Common PE Sections</h3>

<p>While section names are conventions rather than requirements, most PE files contain these standard sections:</p>

<ul>
  <li><strong>.text</strong>: Contains executable code</li>
  <li><strong>.data</strong>: Contains initialized data</li>
  <li><strong>.rdata</strong>: Contains read-only data like constants and strings</li>
  <li><strong>.bss</strong>: Represents uninitialized data (doesn’t actually occupy file space)</li>
  <li><strong>.rsrc</strong>: Contains resources like icons, dialogs, and version information</li>
  <li><strong>.reloc</strong>: Contains relocation information</li>
  <li><strong>.idata</strong>: Contains import directory information</li>
  <li><strong>.edata</strong>: Contains export directory information</li>
</ul>

<h3 id="pe-data-directories">PE Data Directories</h3>

<p>The Optional Header includes an array of data directories that point to important structures within the file:</p>

<ul>
  <li><strong>Export Table</strong>: Functions and data exported by this module</li>
  <li><strong>Import Table</strong>: Functions and data imported from other modules</li>
  <li><strong>Resource Table</strong>: Resources like icons, dialogs, and strings</li>
  <li><strong>Exception Table</strong>: Exception handling information</li>
  <li><strong>Certificate Table</strong>: Digital signature information</li>
  <li><strong>Base Relocation Table</strong>: Address adjustment information</li>
  <li><strong>Debug</strong>: Debug information</li>
  <li><strong>TLS Table</strong>: Thread Local Storage data</li>
  <li><strong>Load Config Table</strong>: Load configuration data</li>
  <li><strong>Bound Import Table</strong>: Precomputed addresses of imports</li>
  <li><strong>Import Address Table (IAT)</strong>: Runtime function pointers for imports</li>
  <li><strong>Delay Import Descriptor</strong>: Information for delayed loading of DLLs</li>
  <li><strong>CLR Runtime Header</strong>: .NET metadata and entry points</li>
</ul>

<p>These directories are crucial for understanding how the program interacts with external components and for locating important structures during analysis.</p>

<h3 id="analyzing-pe-files">Analyzing PE Files</h3>

<p>Let’s examine how to extract and analyze information from PE files using practical tools.</p>

<h4 id="using-cff-explorer">Using CFF Explorer</h4>

<p>CFF Explorer is a powerful PE file editor and viewer that provides a graphical interface for examining PE structures.</p>

<p>To analyze a PE file with CFF Explorer:</p>

<ol>
  <li>Open the executable in CFF Explorer</li>
  <li>Navigate through the tree view to examine different components:
    <ul>
      <li>NT Headers &gt; File Header: Basic file information</li>
      <li>NT Headers &gt; Optional Header: Entry point, base address, etc.</li>
      <li>Section Headers: Section properties and characteristics</li>
      <li>Import Directory: Imported functions</li>
      <li>Export Directory: Exported functions</li>
      <li>Resources: Embedded resources</li>
    </ul>
  </li>
</ol>

<p>CFF Explorer also provides hex and disassembly views, making it a versatile tool for initial PE analysis.</p>

<h4 id="using-peid-for-packer-detection">Using PEiD for Packer Detection</h4>

<p>Packed executables are compressed or encrypted to hinder analysis. PEiD helps identify common packers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PEiD detected: UPX 3.91 [NRV2B] -&gt; Markus Oberhumer, Laszlo Molnar &amp; John Reiser
</code></pre></div></div>

<p>If a packer is detected, you’ll typically need to unpack the executable before further analysis.</p>

<h4 id="using-dumpbin">Using DUMPBIN</h4>

<p>DUMPBIN is a command-line tool included with Visual Studio that provides detailed information about PE files:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; dumpbin /headers program.exe
Microsoft (R) COFF/PE Dumper Version 14.00.24215.1
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file program.exe

PE signature found

File Type: EXECUTABLE IMAGE

FILE HEADER VALUES
            8664 machine (x64)
               6 number of sections
        5F0EEFBB time date stamp Tue Jul 14 15:30:35 2020
               0 file pointer to symbol table
               0 number of symbols
              F0 size of optional header
              22 characteristics
                   Executable
                   Application can handle large (&gt;2GB) addresses

OPTIONAL HEADER VALUES
             20B magic # (PE32+)
           14.16 linker version
           12800 size of code
            6600 size of initialized data
               0 size of uninitialized data
            5A90 entry point (0000000140005A90)
            1000 base of code
         140000000 image base (0000000140000000 to 000000014002FFFF)
            1000 section alignment
             200 file alignment
...
</code></pre></div></div>

<p>DUMPBIN offers various switches for examining specific aspects of PE files:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/imports</code>: Lists imported functions</li>
  <li><code class="language-plaintext highlighter-rouge">/exports</code>: Lists exported functions</li>
  <li><code class="language-plaintext highlighter-rouge">/dependents</code>: Shows dependent DLLs</li>
  <li><code class="language-plaintext highlighter-rouge">/disasm</code>: Disassembles code sections</li>
  <li><code class="language-plaintext highlighter-rouge">/all</code>: Displays all available information</li>
</ul>

<h4 id="using-pe-bear">Using PE-bear</h4>

<p>PE-bear is another graphical PE analysis tool with a focus on malware analysis. It provides a clean interface for examining PE structures and includes features for detecting anomalies that might indicate malicious modifications.</p>

<h3 id="pe-file-peculiarities-and-tricks">PE File Peculiarities and Tricks</h3>

<p>Reverse engineers should be aware of several PE format peculiarities that can affect analysis:</p>

<h4 id="base-address-randomization-aslr">Base Address Randomization (ASLR)</h4>

<p>Address Space Layout Randomization loads executables at different base addresses each time they run, complicating dynamic analysis. You can identify if ASLR is enabled by checking the DLL Characteristics in the Optional Header:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DLL Characteristics: 8160 (0x1FE0)
  High Entropy Virtual Address Space
  Dynamic base
  NX compatible
  No structured exception handler
  Control Flow Guard
  Terminal Server aware
</code></pre></div></div>

<p>The “Dynamic base” flag indicates ASLR support.</p>

<h4 id="bound-imports">Bound Imports</h4>

<p>Bound imports include precomputed addresses for imported functions to speed up loading. However, these bindings become invalid if the referenced DLL changes or loads at a different address. The Bound Import Directory contains this information.</p>

<h4 id="resource-hierarchy">Resource Hierarchy</h4>

<p>The PE resource section uses a hierarchical structure with three levels:</p>
<ol>
  <li>Type (e.g., icons, dialogs, string tables)</li>
  <li>Name/ID (identifier within the type)</li>
  <li>Language (for internationalization)</li>
</ol>

<p>This structure allows efficient organization of resources but can be complex to navigate programmatically.</p>

<h2 id="elf-executable-and-linkable-format">ELF (Executable and Linkable Format)</h2>

<p>The Executable and Linkable Format is the standard binary format for Unix-like systems, including Linux, BSD, and Solaris. It’s used for executables, shared libraries, object files, and core dumps.</p>

<h3 id="elf-file-structure">ELF File Structure</h3>

<p>An ELF file consists of these main components:</p>

<ol>
  <li><strong>ELF Header</strong>: Contains basic file information, including:
    <ul>
      <li>Magic number (\x7FELF)</li>
      <li>File class (32-bit or 64-bit)</li>
      <li>Data encoding (little or big endian)</li>
      <li>ELF version</li>
      <li>Target OS ABI</li>
      <li>File type (executable, shared object, etc.)</li>
      <li>Machine type (architecture)</li>
      <li>Entry point address</li>
    </ul>
  </li>
  <li><strong>Program Header Table</strong>: Describes segments used at runtime, including:
    <ul>
      <li>Segment type (load, dynamic, interp, etc.)</li>
      <li>Offset in file</li>
      <li>Virtual address for loading</li>
      <li>Segment size in file and memory</li>
      <li>Required alignment</li>
      <li>Flags (read, write, execute)</li>
    </ul>
  </li>
  <li><strong>Section Header Table</strong>: Describes sections used for linking and debugging:
    <ul>
      <li>Section name (index into string table)</li>
      <li>Section type (program data, symbol table, etc.)</li>
      <li>Section attributes</li>
      <li>Memory address</li>
      <li>Offset in file</li>
      <li>Section size</li>
    </ul>
  </li>
  <li><strong>Sections/Segments</strong>: The actual content of the file.</li>
</ol>

<p>Here’s a simplified visualization of an ELF file structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────┐
│     ELF Header      │
├─────────────────────┤
│ Program Header Table│
├─────────────────────┤
│      Segments       │
│    (.text, .data,   │
│     .rodata, etc.)  │
├─────────────────────┤
│ Section Header Table│
└─────────────────────┘
</code></pre></div></div>

<p>It’s important to note that ELF uses two parallel views of the file:</p>
<ul>
  <li><strong>Segments</strong> (described by program headers) are used by the loader at runtime</li>
  <li><strong>Sections</strong> (described by section headers) are used for linking and debugging</li>
</ul>

<p>A segment typically contains multiple sections with similar attributes.</p>

<h3 id="common-elf-sections">Common ELF Sections</h3>

<p>Standard ELF sections include:</p>

<ul>
  <li><strong>.text</strong>: Executable code</li>
  <li><strong>.data</strong>: Initialized data</li>
  <li><strong>.rodata</strong>: Read-only data (constants and strings)</li>
  <li><strong>.bss</strong>: Uninitialized data</li>
  <li><strong>.symtab</strong>: Symbol table</li>
  <li><strong>.strtab</strong>: String table</li>
  <li><strong>.dynamic</strong>: Dynamic linking information</li>
  <li><strong>.plt</strong>: Procedure Linkage Table (for resolving imported functions)</li>
  <li><strong>.got</strong>: Global Offset Table (contains addresses for imported symbols)</li>
  <li><strong>.init/.fini</strong>: Initialization and finalization code</li>
  <li><strong>.eh_frame</strong>: Exception handling information</li>
</ul>

<h3 id="analyzing-elf-files">Analyzing ELF Files</h3>

<p>Let’s explore tools and techniques for analyzing ELF files.</p>

<h4 id="using-readelf">Using readelf</h4>

<p>readelf is a command-line tool that displays information about ELF files:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>readelf <span class="nt">-h</span> executable
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2<span class="s1">'s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x401040
  Start of program headers:          64 (bytes into file)
  Start of section headers:          13144 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         11
  Size of section headers:           64 (bytes)
  Number of section headers:         30
  Section header string table index: 29
</span></code></pre></div></div>

<p>readelf offers various options for examining specific aspects of ELF files:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-l</code>: Lists program headers (segments)</li>
  <li><code class="language-plaintext highlighter-rouge">-S</code>: Lists section headers</li>
  <li><code class="language-plaintext highlighter-rouge">-s</code>: Displays the symbol table</li>
  <li><code class="language-plaintext highlighter-rouge">-d</code>: Shows dynamic section information</li>
  <li><code class="language-plaintext highlighter-rouge">-r</code>: Displays relocation entries</li>
  <li><code class="language-plaintext highlighter-rouge">-x &lt;section&gt;</code>: Dumps the contents of a section as hexadecimal bytes</li>
</ul>

<h4 id="using-objdump">Using objdump</h4>

<p>objdump is another powerful command-line tool for analyzing ELF files, with a focus on disassembly:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>objdump <span class="nt">-d</span> executable

executable:     file format elf64-x86-64

Disassembly of section .text:

0000000000401040 &lt;_start&gt;:
  401040:       31 ed                   xor    %ebp,%ebp
  401042:       49 89 d1                mov    %rdx,%r9
  401045:       5e                      pop    %rsi
  401046:       48 89 e2                mov    %rsp,%rdx
  401049:       48 83 e4 f0             and    <span class="nv">$0xfffffffffffffff0</span>,%rsp
  40104d:       50                      push   %rax
  40104e:       54                      push   %rsp
  40104f:       49 c7 c0 10 12 40 00    mov    <span class="nv">$0x401210</span>,%r8
  401056:       48 c7 c1 a0 11 40 00    mov    <span class="nv">$0x4011a0</span>,%rcx
  40105d:       48 c7 c7 30 11 40 00    mov    <span class="nv">$0x401130</span>,%rdi
  401064:       ff 15 66 2f 00 00       callq  <span class="k">*</span>0x2f66<span class="o">(</span>%rip<span class="o">)</span>        <span class="c"># 403fd0 &lt;__libc_start_main@GLIBC_2.2.5&gt;</span>
  40106a:       f4                      hlt    
...
</code></pre></div></div>

<p>Useful objdump options include:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-d</code>: Disassembles executable sections</li>
  <li><code class="language-plaintext highlighter-rouge">-D</code>: Disassembles all sections</li>
  <li><code class="language-plaintext highlighter-rouge">-s</code>: Displays full contents of all sections</li>
  <li><code class="language-plaintext highlighter-rouge">-t</code>: Displays the symbol table</li>
  <li><code class="language-plaintext highlighter-rouge">-R</code>: Displays dynamic relocation entries</li>
  <li><code class="language-plaintext highlighter-rouge">--no-show-raw-insn</code>: Shows only the disassembly, not the hex bytes</li>
</ul>

<h4 id="using-ldd">Using ldd</h4>

<p>ldd identifies the shared libraries an executable depends on:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ldd executable
        linux-vdso.so.1 <span class="o">(</span>0x00007ffcb5563000<span class="o">)</span>
        libc.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="o">(</span>0x00007f56b33c4000<span class="o">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f56b35c1000<span class="o">)</span>
</code></pre></div></div>

<p>This information helps understand the executable’s external dependencies.</p>

<h4 id="using-nm">Using nm</h4>

<p>nm lists symbols from object files and executables:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nm executable
0000000000403ff0 B __bss_start
0000000000403ff0 b completed.7698
0000000000403fe0 D __data_start
0000000000403fe0 W data_start
0000000000401070 t deregister_tm_clones
00000000004010e0 t __do_global_dtors_aux
0000000000403de8 t __do_global_dtors_aux_fini_array_entry
0000000000403fe8 D __dso_handle
0000000000403df8 d _DYNAMIC
0000000000403ff0 D _edata
0000000000404000 B _end
00000000004011c4 T _fini
0000000000401100 t frame_dummy
0000000000403de0 t __frame_dummy_init_array_entry
0000000000402154 r __FRAME_END__
0000000000404000 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
0000000000402004 r __GNU_EH_FRAME_HDR
0000000000401000 T _init
0000000000403de8 t __init_array_end
0000000000403de0 t __init_array_start
00000000004011d0 R _IO_stdin_used
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
00000000004011c0 T __libc_csu_fini
0000000000401150 T __libc_csu_init
                 U __libc_start_main@@GLIBC_2.2.5
0000000000401130 T main
00000000004010a0 t register_tm_clones
0000000000401040 T _start
0000000000403ff0 D __TMC_END__
</code></pre></div></div>

<p>The output shows symbol addresses, types, and names. Symbol types include:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">T/t</code>: Text (code) section symbol (uppercase for global)</li>
  <li><code class="language-plaintext highlighter-rouge">D/d</code>: Initialized data section symbol</li>
  <li><code class="language-plaintext highlighter-rouge">B/b</code>: BSS section symbol</li>
  <li><code class="language-plaintext highlighter-rouge">U</code>: Undefined symbol (imported)</li>
  <li><code class="language-plaintext highlighter-rouge">R/r</code>: Read-only data section symbol</li>
</ul>

<h3 id="elf-file-peculiarities-and-tricks">ELF File Peculiarities and Tricks</h3>

<p>Several ELF features are particularly relevant for reverse engineers:</p>

<h4 id="position-independent-executables-pie">Position-Independent Executables (PIE)</h4>

<p>PIE executables can be loaded at any address, similar to ASLR in Windows. You can identify PIE executables by checking the ELF header type:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Type: DYN (Shared object file)
</code></pre></div></div>

<p>For PIE executables, the type is DYN rather than EXEC, even though they are executables.</p>

<h4 id="symbol-versioning">Symbol Versioning</h4>

<p>ELF supports symbol versioning to handle multiple versions of the same function in a shared library. Versioned symbols appear with <code class="language-plaintext highlighter-rouge">@@</code> or <code class="language-plaintext highlighter-rouge">@</code> in nm output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>U __libc_start_main@@GLIBC_2.2.5
</code></pre></div></div>

<p>This indicates that the program requires version 2.2.5 or newer of this function.</p>

<h4 id="rpath-and-runpath">RPATH and RUNPATH</h4>

<p>ELF executables can specify custom library search paths using RPATH and RUNPATH entries in the dynamic section. These can be viewed with readelf:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>readelf <span class="nt">-d</span> executable | <span class="nb">grep</span> <span class="nt">-i</span> path
 0x000000000000001d <span class="o">(</span>RUNPATH<span class="o">)</span>            Library runpath: <span class="o">[</span>/opt/myapp/lib]
</code></pre></div></div>

<p>This information can be important when analyzing executables that use non-standard library locations.</p>

<h2 id="mach-o-format">Mach-O Format</h2>

<p>Mach-O (Mach Object) is the executable format used by macOS, iOS, and other Apple operating systems. It evolved from the Mach kernel’s object format.</p>

<h3 id="mach-o-file-structure">Mach-O File Structure</h3>

<p>A Mach-O file consists of these main components:</p>

<ol>
  <li><strong>Header</strong>: Contains basic file information, including:
    <ul>
      <li>Magic number (0xFEEDFACE for 32-bit, 0xFEEDFACF for 64-bit)</li>
      <li>CPU type and subtype</li>
      <li>File type (executable, dylib, etc.)</li>
      <li>Number of load commands</li>
    </ul>
  </li>
  <li><strong>Load Commands</strong>: Instructions for the dynamic loader, including:
    <ul>
      <li>Segment definitions</li>
      <li>Symbol table location</li>
      <li>Dynamic linking information</li>
      <li>Entry point information</li>
    </ul>
  </li>
  <li><strong>Segments and Sections</strong>: The actual content of the file, organized into segments (similar to ELF segments) that contain one or more sections.</li>
</ol>

<p>Here’s a simplified visualization of a Mach-O file structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────┐
│    Mach-O Header    │
├─────────────────────┤
│    Load Commands    │
├─────────────────────┤
│      Segments       │
│    (__TEXT, __DATA, │
│     __LINKEDIT)     │
└─────────────────────┘
</code></pre></div></div>

<h3 id="common-mach-o-segments-and-sections">Common Mach-O Segments and Sections</h3>

<p>Standard Mach-O segments include:</p>

<ul>
  <li><strong>__TEXT</strong>: Contains executable code and read-only data
    <ul>
      <li>__text: Executable code</li>
      <li>__const: Constants</li>
      <li>__stubs: Stub functions for dynamic linking</li>
      <li>__stub_helper: Helper functions for stubs</li>
    </ul>
  </li>
  <li><strong>__DATA</strong>: Contains writable data
    <ul>
      <li>__data: Initialized variables</li>
      <li>__bss: Uninitialized variables</li>
      <li>__la_symbol_ptr: Lazy symbol pointers</li>
      <li>__nl_symbol_ptr: Non-lazy symbol pointers</li>
    </ul>
  </li>
  <li><strong>__LINKEDIT</strong>: Contains linking information
    <ul>
      <li>Symbol tables</li>
      <li>String tables</li>
      <li>Code signature</li>
      <li>Relocation entries</li>
    </ul>
  </li>
</ul>

<h3 id="analyzing-mach-o-files">Analyzing Mach-O Files</h3>

<p>Let’s explore tools and techniques for analyzing Mach-O files.</p>

<h4 id="using-otool">Using otool</h4>

<p>otool is a command-line tool for examining Mach-O files on macOS:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>otool <span class="nt">-h</span> executable
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
 0xfeedfacf 16777223          3  0x80           2    16       1296   0x200085
</code></pre></div></div>

<p>Useful otool options include:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-l</code>: Displays load commands</li>
  <li><code class="language-plaintext highlighter-rouge">-L</code>: Shows shared libraries the executable uses</li>
  <li><code class="language-plaintext highlighter-rouge">-t</code>: Disassembles the __text section</li>
  <li><code class="language-plaintext highlighter-rouge">-s &lt;segment&gt; &lt;section&gt;</code>: Displays the contents of a specific section</li>
  <li><code class="language-plaintext highlighter-rouge">-v</code>: Provides verbose output</li>
</ul>

<h4 id="using-nm-on-macos">Using nm on macOS</h4>

<p>nm works with Mach-O files similar to its ELF counterpart:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nm executable
0000000100000000 T __mh_execute_header
0000000100003f50 T _main
                 U _printf
                 U dyld_stub_binder
</code></pre></div></div>

<h4 id="using-machoview">Using MachOView</h4>

<p>MachOView is a graphical tool for examining Mach-O files, providing a hierarchical view of the file structure and detailed information about each component.</p>

<h3 id="mach-o-file-peculiarities-and-tricks">Mach-O File Peculiarities and Tricks</h3>

<p>Several Mach-O features are particularly relevant for reverse engineers:</p>

<h4 id="fat-binaries">Fat Binaries</h4>

<p>Mach-O supports “fat” or “universal” binaries that contain code for multiple architectures in a single file. You can identify fat binaries using the file command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>file executable
executable: Mach-O universal binary with 2 architectures: <span class="o">[</span>x86_64:Mach-O 64-bit executable x86_64] <span class="o">[</span>arm64:Mach-O 64-bit executable arm64]
</code></pre></div></div>

<p>To examine a specific architecture in a fat binary, use the -arch option with otool:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>otool <span class="nt">-arch</span> arm64 <span class="nt">-h</span> executable
</code></pre></div></div>

<h4 id="code-signing">Code Signing</h4>

<p>Mach-O files on modern Apple systems are typically code signed. The signature is stored in the __LINKEDIT segment and can be examined with the codesign tool:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>codesign <span class="nt">-d</span> <span class="nt">-v</span> executable
<span class="nv">Executable</span><span class="o">=</span>/path/to/executable
<span class="nv">Identifier</span><span class="o">=</span>com.example.executable
<span class="nv">Format</span><span class="o">=</span>Mach-O thin <span class="o">(</span>x86_64<span class="o">)</span>
CodeDirectory <span class="nv">v</span><span class="o">=</span>20500 <span class="nv">size</span><span class="o">=</span>12699 <span class="nv">flags</span><span class="o">=</span>0x10000<span class="o">(</span>runtime<span class="o">)</span> <span class="nv">hashes</span><span class="o">=</span>389+5 <span class="nv">location</span><span class="o">=</span>embedded
Signature <span class="nv">size</span><span class="o">=</span>4442
<span class="nv">Authority</span><span class="o">=</span>Developer ID Application: Example Corp <span class="o">(</span>A1B2C3D4E5<span class="o">)</span>
<span class="nv">Authority</span><span class="o">=</span>Developer ID Certification Authority
<span class="nv">Authority</span><span class="o">=</span>Apple Root CA
Info.plist<span class="o">=</span>not bound
<span class="nv">TeamIdentifier</span><span class="o">=</span>A1B2C3D4E5
Runtime <span class="nv">Version</span><span class="o">=</span>10.15.0
Designated <span class="o">=&gt;</span> identifier <span class="s2">"com.example.executable"</span> and certificate leaf <span class="o">[</span>subject.CN] <span class="o">=</span> <span class="s2">"Developer ID Application: Example Corp (A1B2C3D4E5)"</span> trusted, signed
</code></pre></div></div>

<h4 id="two-level-namespace">Two-Level Namespace</h4>

<p>Mach-O uses a “two-level namespace” for symbols, where each symbol reference includes both the symbol name and the library where it should be found. This helps avoid conflicts between libraries that define the same symbol.</p>

<h2 id="android-dex-format">Android DEX Format</h2>

<p>Dalvik Executable (DEX) is the format used for Android applications. While Android apps are typically written in Java or Kotlin, they’re compiled to DEX bytecode rather than Java bytecode.</p>

<h3 id="dex-file-structure">DEX File Structure</h3>

<p>A DEX file consists of these main components:</p>

<ol>
  <li><strong>Header</strong>: Contains basic file information, including:
    <ul>
      <li>Magic number (“dex\n035\0” for version 35)</li>
      <li>Checksum and signature</li>
      <li>File size</li>
      <li>Endianness tag</li>
      <li>Offsets to various sections</li>
    </ul>
  </li>
  <li>
    <p><strong>String Table</strong>: Contains all string literals used in the program</p>
  </li>
  <li>
    <p><strong>Type Table</strong>: Lists all types (classes) referenced in the program</p>
  </li>
  <li>
    <p><strong>Prototype Table</strong>: Describes method signatures</p>
  </li>
  <li>
    <p><strong>Field Table</strong>: Describes class fields</p>
  </li>
  <li>
    <p><strong>Method Table</strong>: Describes class methods</p>
  </li>
  <li>
    <p><strong>Class Definitions</strong>: Contains detailed information about each class</p>
  </li>
  <li><strong>Data Section</strong>: Contains the actual bytecode and data</li>
</ol>

<h3 id="analyzing-dex-files">Analyzing DEX Files</h3>

<p>Let’s explore tools for analyzing DEX files.</p>

<h4 id="using-dexdump">Using dexdump</h4>

<p>dexdump is a tool included with the Android SDK that displays the contents of DEX files:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>dexdump <span class="nt">-f</span> classes.dex
Processing <span class="s1">'classes.dex'</span>...
Magic: <span class="s1">'dex\n035\0'</span>
Checksum: 8c78965
Signature: 5881...
File size: 2840 bytes
Header size: 112 bytes
Endian tag: 0x12345678
Link size: 0
Link off: 0
Map off: 2700
String ids size: 55
String ids off: 112
Type ids size: 16
Type ids off: 332
Proto ids size: 15
Proto ids off: 396
Field ids size: 10
Field ids off: 576
Method ids size: 29
Method ids off: 656
Class defs size: 5
Class defs off: 888
Data size: 1752
Data off: 948
</code></pre></div></div>

<p>For more detailed information, including disassembly of the bytecode, use the -d option:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>dexdump <span class="nt">-d</span> classes.dex
</code></pre></div></div>

<h4 id="using-jadx">Using jadx</h4>

<p>jadx is a powerful tool that can decompile DEX files back to Java source code:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jadx <span class="nt">-d</span> output_directory classes.dex
</code></pre></div></div>

<p>This creates a directory structure with Java source files, making it much easier to understand the application’s functionality.</p>

<h4 id="using-apktool">Using apktool</h4>

<p>For complete Android applications (APK files), apktool can extract and decode resources as well as disassemble DEX files to a more readable format called smali:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>apktool d application.apk <span class="nt">-o</span> output_directory
</code></pre></div></div>

<p>This extracts the application’s resources, manifest, and DEX files (converted to smali format).</p>

<h3 id="dex-file-peculiarities-and-tricks">DEX File Peculiarities and Tricks</h3>

<p>Several DEX features are particularly relevant for reverse engineers:</p>

<h4 id="multiple-dex-files">Multiple DEX Files</h4>

<p>Android applications can contain multiple DEX files (classes.dex, classes2.dex, etc.) to overcome the method limit of 65,536 methods per DEX file. When analyzing large applications, you need to examine all DEX files.</p>

<h4 id="obfuscation">Obfuscation</h4>

<p>Many Android applications use ProGuard or similar tools to obfuscate their code by renaming classes, methods, and fields to meaningless names like a, b, c, etc. This makes reverse engineering more challenging but doesn’t change the program’s functionality.</p>

<h4 id="native-code">Native Code</h4>

<p>Android applications can include native code (shared libraries) in addition to DEX files. These libraries are typically found in the lib/ directory of the APK and need to be analyzed separately using ELF analysis tools.</p>

<h2 id="net-assemblies">.NET Assemblies</h2>

<p>.NET assemblies are the executable format for .NET applications, used on Windows, macOS, and Linux through .NET Core/.NET 5+.</p>

<h3 id="net-assembly-structure">.NET Assembly Structure</h3>

<p>A .NET assembly consists of these main components:</p>

<ol>
  <li>
    <p><strong>PE/COFF Header</strong>: .NET assemblies use the PE format as a container</p>
  </li>
  <li>
    <p><strong>CLR Header</strong>: Contains information specific to the Common Language Runtime</p>
  </li>
  <li>
    <p><strong>Metadata Tables</strong>: Describe the assembly’s types, methods, fields, etc.</p>
  </li>
  <li>
    <p><strong>IL Code</strong>: The actual program code in Intermediate Language (IL) bytecode</p>
  </li>
  <li>
    <p><strong>Resources</strong>: Embedded resources like images, strings, etc.</p>
  </li>
  <li>
    <p><strong>Strong Name Signature</strong>: Optional digital signature for the assembly</p>
  </li>
</ol>

<h3 id="analyzing-net-assemblies">Analyzing .NET Assemblies</h3>

<p>Let’s explore tools for analyzing .NET assemblies.</p>

<h4 id="using-ildasm">Using ILDASM</h4>

<p>ILDASM (IL Disassembler) is a tool included with the .NET SDK that displays the contents of .NET assemblies:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ildasm /text assembly.exe

// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly Sample
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .hash algorithm 0x00008004
  .ver 0:0:0:0
}
.module Sample.exe
// MVID: {A67FC21F-23A5-4587-A41A-0F5EBB3A4016}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0003       // WINDOWS_CUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x06DD0000

// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi beforefieldinit Sample.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // Code size       13 (0xd)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ldstr      "Hello, World!"
    IL_0006:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_000b:  nop
    IL_000c:  ret
  } // end of method Program::Main

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ret
  } // end of method Program::.ctor

} // end of class Sample.Program
</code></pre></div></div>

<h4 id="using-dnspy">Using dnSpy</h4>

<p>dnSpy is a powerful .NET assembly browser, decompiler, and debugger that provides a graphical interface for examining .NET assemblies. It can decompile IL code to C#, Visual Basic, or IL, and allows editing and debugging of assemblies.</p>

<h4 id="using-ilspy">Using ILSpy</h4>

<p>ILSpy is another popular .NET decompiler that can convert assemblies back to C# or Visual Basic source code:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ilspy assembly.exe <span class="nt">-o</span> output_directory
</code></pre></div></div>

<p>This creates a directory with decompiled source files.</p>

<h3 id="net-assembly-peculiarities-and-tricks">.NET Assembly Peculiarities and Tricks</h3>

<p>Several .NET features are particularly relevant for reverse engineers:</p>

<h4 id="metadata">Metadata</h4>

<p>.NET assemblies contain rich metadata that describes all types, methods, fields, and other elements. This metadata makes .NET assemblies relatively easy to reverse engineer compared to native executables.</p>

<h4 id="obfuscation-1">Obfuscation</h4>

<p>Many .NET applications use obfuscation tools like Dotfuscator or ConfuseEx to make reverse engineering more difficult. Common obfuscation techniques include:</p>
<ul>
  <li>Renaming symbols to meaningless or confusing names</li>
  <li>Control flow obfuscation</li>
  <li>String encryption</li>
  <li>Proxy methods</li>
  <li>Invalid metadata that confuses decompilers</li>
</ul>

<h4 id="native-code-integration">Native Code Integration</h4>

<p>.NET applications can include native code through P/Invoke or by embedding native DLLs. These native components need to be analyzed separately using PE analysis tools.</p>

<h2 id="comparing-executable-formats">Comparing Executable Formats</h2>

<p>Let’s compare the key characteristics of the executable formats we’ve discussed:</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>PE</th>
      <th>ELF</th>
      <th>Mach-O</th>
      <th>DEX</th>
      <th>.NET Assembly</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Platforms</strong></td>
      <td>Windows</td>
      <td>Linux, Unix</td>
      <td>macOS, iOS</td>
      <td>Android</td>
      <td>Cross-platform</td>
    </tr>
    <tr>
      <td><strong>Architecture Support</strong></td>
      <td>Multiple</td>
      <td>Multiple</td>
      <td>Multiple</td>
      <td>Dalvik VM</td>
      <td>CLR</td>
    </tr>
    <tr>
      <td><strong>Code Representation</strong></td>
      <td>Native</td>
      <td>Native</td>
      <td>Native</td>
      <td>Bytecode</td>
      <td>IL Bytecode</td>
    </tr>
    <tr>
      <td><strong>Metadata</strong></td>
      <td>Limited</td>
      <td>Limited</td>
      <td>Limited</td>
      <td>Extensive</td>
      <td>Extensive</td>
    </tr>
    <tr>
      <td><strong>Dynamic Linking</strong></td>
      <td>Imports/Exports</td>
      <td>PLT/GOT</td>
      <td>Stubs/Lazy Binding</td>
      <td>Dynamic Invocation</td>
      <td>Assembly References</td>
    </tr>
    <tr>
      <td><strong>Ease of Reverse Engineering</strong></td>
      <td>Moderate</td>
      <td>Moderate</td>
      <td>Moderate</td>
      <td>Easier</td>
      <td>Easiest</td>
    </tr>
  </tbody>
</table>

<p>This comparison highlights why different approaches are needed when reverse engineering software on different platforms.</p>

<h2 id="practical-techniques-for-format-analysis">Practical Techniques for Format Analysis</h2>

<p>Regardless of the specific format, several general techniques are valuable for analyzing executable files:</p>

<h3 id="identifying-the-format-and-architecture">Identifying the Format and Architecture</h3>

<p>The first step in any analysis is identifying the file format and target architecture. The <code class="language-plaintext highlighter-rouge">file</code> command is invaluable for this purpose:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>file unknown_binary
unknown_binary: ELF 64-bit LSB executable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="k">for </span>GNU/Linux 2.6.32
</code></pre></div></div>

<p>This immediately tells you it’s a 64-bit ELF executable for x86-64 architecture.</p>

<h3 id="examining-strings">Examining Strings</h3>

<p>Extracted strings often provide valuable insights into a program’s functionality:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>strings executable | <span class="nb">grep</span> <span class="nt">-i</span> password
Enter password:
Password incorrect!
Password accepted.
/etc/passwd
</code></pre></div></div>

<p>Strings can reveal error messages, file paths, URLs, and other valuable information.</p>

<h3 id="identifying-external-dependencies">Identifying External Dependencies</h3>

<p>Understanding a program’s external dependencies helps map its functionality:</p>

<ul>
  <li>For PE files: Use <code class="language-plaintext highlighter-rouge">depends.exe</code> or <code class="language-plaintext highlighter-rouge">dumpbin /dependents</code></li>
  <li>For ELF files: Use <code class="language-plaintext highlighter-rouge">ldd</code></li>
  <li>For Mach-O files: Use <code class="language-plaintext highlighter-rouge">otool -L</code></li>
  <li>For .NET assemblies: Use <code class="language-plaintext highlighter-rouge">ildasm</code> to view assembly references</li>
</ul>

<p>External dependencies often reveal the program’s capabilities (networking, cryptography, database access, etc.).</p>

<h3 id="locating-the-entry-point">Locating the Entry Point</h3>

<p>Finding where execution begins provides a starting point for analysis:</p>

<ul>
  <li>For PE files: The AddressOfEntryPoint field in the Optional Header</li>
  <li>For ELF files: The e_entry field in the ELF header</li>
  <li>For Mach-O files: The LC_MAIN or LC_UNIXTHREAD load command</li>
  <li>For .NET assemblies: The method marked with .entrypoint in IL</li>
</ul>

<p>From the entry point, you can follow the execution flow to understand the program’s initialization and main logic.</p>

<h3 id="identifying-compiler-patterns">Identifying Compiler Patterns</h3>

<p>Different compilers generate distinctive code patterns, especially for program initialization. Recognizing these patterns helps understand the code’s structure:</p>

<ul>
  <li>MSVC executables typically include a complex startup routine that calls the C runtime initialization before main()</li>
  <li>GCC executables have a simpler startup that quickly transfers control to __libc_start_main</li>
  <li>Executables compiled with optimization may have significantly different code patterns than debug builds</li>
</ul>

<p>Familiarity with these patterns comes with experience and can significantly speed up analysis.</p>

<h2 id="summary">Summary</h2>

<p>In this chapter, we’ve explored the major executable formats used across different platforms, examining their structures, components, and analysis techniques. Understanding these formats is fundamental to reverse engineering because they define how program code and data are organized and accessed.</p>

<p>Key takeaways include:</p>

<ul>
  <li>Executable formats serve as containers that organize code, data, and metadata in a structure the operating system can load and execute</li>
  <li>Each platform uses specific formats with unique characteristics: PE for Windows, ELF for Linux/Unix, Mach-O for macOS/iOS, DEX for Android, and .NET assemblies for .NET applications</li>
  <li>Despite their differences, these formats share common elements like headers, code sections, data sections, and linking information</li>
  <li>Various tools are available for analyzing each format, from command-line utilities to sophisticated graphical interfaces</li>
  <li>Understanding format-specific features and peculiarities is essential for effective reverse engineering</li>
</ul>

<p>With this foundation in executable formats, you’re now prepared to dive deeper into the code they contain. In the next chapter, we’ll explore assembly language basics, building on this structural understanding to interpret the actual instructions that make up a program.</p>

<h2 id="exercises">Exercises</h2>

<ol>
  <li>
    <p><strong>Format Identification</strong>: Collect executable files from different platforms (Windows, Linux, macOS, Android) and use the <code class="language-plaintext highlighter-rouge">file</code> command to identify their formats and characteristics. Document the differences you observe in the output.</p>
  </li>
  <li><strong>PE Analysis</strong>: Using a Windows executable of your choice:
    <ul>
      <li>Identify its imported DLLs and functions using <code class="language-plaintext highlighter-rouge">dumpbin /imports</code> or a similar tool</li>
      <li>Locate the entry point address using a PE viewer</li>
      <li>List the sections and their characteristics</li>
      <li>Determine if ASLR is enabled</li>
    </ul>
  </li>
  <li><strong>ELF Analysis</strong>: Using a Linux executable of your choice:
    <ul>
      <li>Identify its shared library dependencies using <code class="language-plaintext highlighter-rouge">ldd</code></li>
      <li>Extract and analyze the symbol table using <code class="language-plaintext highlighter-rouge">nm</code></li>
      <li>Disassemble the main function using <code class="language-plaintext highlighter-rouge">objdump -d</code></li>
      <li>Determine if it’s a position-independent executable (PIE)</li>
    </ul>
  </li>
  <li><strong>Cross-Format Comparison</strong>: Choose a simple open-source program that can be compiled for multiple platforms. Compile it for Windows, Linux, and macOS if possible. Compare the resulting executables in terms of:
    <ul>
      <li>File size</li>
      <li>Section/segment organization</li>
      <li>External dependencies</li>
      <li>Entry point code</li>
    </ul>
  </li>
  <li><strong>Format Manipulation</strong>: Using a hex editor and format documentation:
    <ul>
      <li>Modify a non-critical field in a PE or ELF header (such as the timestamp)</li>
      <li>Observe how the change affects the file’s behavior and how analysis tools interpret it</li>
      <li>Restore the original value</li>
    </ul>
  </li>
</ol>


  </div>

  <nav class="chapter-navigation">
    
    <a href="/inside-the-machine/chapters/chapter-03-reverse-engineering-tools-and-techniques/" class="prev">&laquo; Chapter 3: Reverse Engineering Tools and Techniques</a>
    
    
    <a href="/inside-the-machine/chapters" class="toc">Table of Contents</a>
    
    
    <a href="/inside-the-machine/chapters/chapter-05-assembly-language-basics/" class="next">Chapter 5: Assembly Language Basics &raquo;</a>
    
  </nav>
</article>
  </main>

  <footer class="site-footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-info">
          <h2>Inside the Machine</h2>
          <p>A comprehensive guide to the art of reverse engineering, exploring various techniques and strategies to extract valuable insights from software systems.
</p>
        </div>
        <div class="footer-contact">
          <h3>Contact</h3>
          <ul class="footer-list">
            <li><a href="mailto:immadmohit@gmail.com">immadmohit@gmail.com</a></li>
            <li><a href="https://github.com/mohitmishra786">GitHub</a></li>
          </ul>
        </div>
        <div class="footer-links">
          <h3>Quick Links</h3>
          <ul class="footer-list">
            <li><a href="/inside-the-machine/">Home</a></li>
            <li><a href="/inside-the-machine/chapters">Chapters</a></li>
            <li><a href="/inside-the-machine/about">About</a></li>
          </ul>
        </div>
      </div>
      <div class="footer-copyright">
        <p>&copy; Mohit Mishra. All rights reserved.</p>
      </div>
    </div>
  </footer>
  
  <script>
    // Dark mode toggle functionality
    document.addEventListener('DOMContentLoaded', function() {
      const themeToggle = document.getElementById('theme-toggle');
      const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
      
      // Check for saved theme preference or use the system preference
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark' || (!savedTheme && prefersDarkScheme.matches)) {
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
      }
      
      // Toggle theme when button is clicked
      themeToggle.addEventListener('click', () => {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
      });
    });
  </script>
</body>
</html>